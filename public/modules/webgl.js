

var webgl = {


  points: [
    -1, -1, 1,
     1, -1, 1,
     1,  1, 1,
     1,  1, 1,
    -1,  1, 1,
    -1, -1, 1,
  ],
  pointNormals: [
    0, 0, 1,
    0, 0, 1,
    0, 0, 1,
    0, 0, 1,
    0, 0, 1,
    0, 0, 1,
  ],
  texCoords: [
    0, 0,
    1, 0,
    1, 1,
    1, 1,
    0, 1,
    0, 0,
  ],
  pointCount: 6,
  deletedPoints: [],

  textureMap: null,
  normalMap: null,


  textureInfo: [
    {
      name: "jerry",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "data:image/jpeg;base64,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",
      gloss: 8
    },
    {
      name: "sub",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "data:image/jpeg;base64,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",
      gloss: 2
    },
    {
      name: "bread",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "./assets/normalMaps/flat.jpeg",
      gloss: 0
    },
    {
      name: "wood",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "./assets/normalMaps/flat.jpeg",
      gloss: 3
    },
    {
      name: "purple",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "data:image/jpeg;base64,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",
      gloss: 8
    },
    {
      name: "tomato",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "https://i.imgur.com/wifJFrB.jpg",
      gloss: 15
    },
    {
      name: "olive",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "data:image/jpeg;base64,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",
      gloss: 15
    },
    {
      name: "pickle",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHCBYWFRgVFhYYGBgaHB4cHRwcGh4eHh4fHhoeHBwaHiMeIS4lHB4rHxwaJjgnKy8xNTU1HCQ7QDs0Py40NTEBDAwMEA8QHhISHzYrJSs0NDQ0Nj02PTRANDY/NjQ2NjY2NDQ0NDY0NDQ0NjY1NDQ2NDQ0NDY9NDQ0NjQ9ND00Pf/AABEIALcBEwMBIgACEQEDEQH/xAAYAAADAQEAAAAAAAAAAAAAAAAAAQIDBP/EADQQAAEDAgQFAwMEAwACAwAAAAEAAhEhMQNBUWEScYGR8CKhscHR4QQTMvFCUmJyghSSwv/EABkBAQEBAQEBAAAAAAAAAAAAAAEAAgMGBP/EACYRAAMAAgICAgEFAQEAAAAAAAABESExAkFRYRJxgSIykaHwwbH/2gAMAwEAAhEDEQA/AOlwaTLiXHdaz7qGzPLlQ/UpkznVepOHHQOIp9kiDdEWnSlE+GYiiqXYNHMnQb/Cosi99Ey7hGhPlVmShV5LQOes/U53C0SYk7DU6J4OCXO9QkCsTTbmtHYkAhoAG2fMpvSHpNCb+nDaudxuyAsOeqTsEmri4i5bqcvn2UQ8/wDI7n7BaAwKmsUnt9Vl3yH6k7TQ4bGNHESzOAQR1WcBtW/B/KnglwJJgZdh91rhgTMGfZEnZpVObTE9wJBNNougO1z9h06e6jHeOIA+bqw7PzsmGUtpecA2mXQqXjiIBpZWDkpbxOdSjbkxpor2NwRjep9oAEAebD3WpZF1P7oDiAT5qhuFMkzPNWtgnG/v+imRKT3xbJHCAL30zSIEweZip/tSHWEHNS+tq8lo81k0Ay+6zOI5xLWwM3OyaNUq7B9wAwkwRMQXHlYdJKMyZSbiAzEltALDigewTAJNRFJ4R7TmeRVfJqzYYTSZgQSRz66BUHXkR58JuJAjzdIYZNDYaGp5aKvYYTjGHQaGg1SYABqTmUiIQGm8wPOyYDRfBFT7+USDzkp4T6QyBrNaa1NUnAu9M8E5kQSNQAs/Yp9ie8C5hZtIc4An0ip1OcD7rUcLXANaDGbpncptxnbCcortJutNuYLF9Ce48VBeVoGOEAiqxYwj1SQdnHsreSaEucT/AK0J6mwQ/QTbEXt1d50QtsMAACG05oWb6NVHOzC4ZLhLifUZnpyWnE4iA0gck2cLbETn53Sc/M0A5LWWHHlVBOOtNUnY4A9IJOQzRh4ZeQAPSKlxoqaWD+Inc17eZoq0U67MmYT3ZFo7nzyibw8SOEGuVO89lb/1TnUbQDsjCbq5xzue6c7ZJtdDwHekk3JtFgFiz9ODLnanz4W+K+lBQWi5UYbf9tZ/AUm42Dw1NFDnATYLk+/NDWipnoVRMDIk2pPJA7CgiZNZjywClrpIAMGp/vp8qS8Teu1Sqab0VCVpLWgvFVZZr59llOxmw2norGDT+Z3nL2U9gv0u+RYbGkuJJEXI+FDv1MgtYDGtY979FePiNa2BRo7ncpYDXcLZPTRPtj3B4eHAEVJ1+U3AUBcA1pkgkSTuhziK6UGpKQaGxM2+c0Mp0U6KAGTc/TqoD2iZpW/03VBhMkUE0lAIBgxIGk5q9AnSMUzQVy5pvZxemDwg21OZOpJTcYNJNJ5Z987Jh5uRfL6Kz0PJXK7LawCXGwECflQ0ACScp66odJF/as/hJwJ+gz0E7fdSXkKMkuoBufogCL9z8hGM2CGjrufPhSRcuFNEpjLoHOOUfVNwkk20QwEmTGsCpAyVQSag2m3kBVJPAqzGmYySmQ7nE59EnGhh23VUWAANBnMqJ+QFoFcpPvkkW7i1kzbredgYSZatyAKXOdNL+ygf7qhhnDVwilBNtyhokTN+6MS5k5aWzPLTqk94NJikd6lCorsniA0TWuHwgCG/CE30PxM2fpoaXEEzYTBNaUrTNaswQCS6YB0oTnyUEk8h8rEMB4pqZ129kRvbBvKb0zTH/UF3paIbrqfqmxkADzy6hmCAAAKXJ16pvcB8/wBJxpCkigRrUmYNM90cF5qdYQBsIjNDjJIGR2QZf6XkTiSNBTmc03uO2ipzI2I5qQDJjKw31UmPIbW0jMnLLmk4AGTkL76K3+kQTLs62G65mt4jJNKRpzUlVSb1DRjWhooZ9ifqqFuqYGn1lU0ZnJVLWBNaM+ZP0UPrEUE5aA1Q8zeg7cghzJvIbpYxr5CZA6cJxAXOByutAd7TYKXv9VAB3gc1YdckjnYdsgh3BJ5f2Jgz0y0R+5BOZp7JyIoYGtZKzc0D/wAj7Cc1fYudgWT6uKNAFbXQOEtG33jLqkRaAm29/j4UxmYyWGKa5+ZpvNbTl7WU4QN5pe/k/K0bhwOIyBeSfeNVNqgngngrU10FdcrAK+Lhk0nUmwWWG53+MMETEcTjvJzTawgffVX2S0GCQ50kw1tSddhqpbiOdLg4uFYBBDR903NJaQakm40sqcA0BrQSQB/SsUyoJuE6JDo7AdkjhmKuc6daczATfxGAacr9E24buR7QFGm2ENFOHhOlI/COFwq65ryQ7QVAFSVLQKd608AShX9A1uZk1ojDkDL7d1YMKWPuD312SzOU1+SWwf5Gk6VIGg0nNaBwJsImPwlhvBkNyNTYdJSwBNQCBYTpmY3WSUbQ5bt2/CFNcmt7ITC+fooOkwCaVOfn4U4TqExSTfNNxIaKQXGeent9UMafv89VdE1mDY/QbTp9kwwmaU1VAUiJ28zKkgN/k5o/5FY7UWb4KVQo3HdZYDDfm4nzVUDxH0glDMJ0eot4BU1ArkNSrSJutMmpvzJyE81fHHpFzUq3MkgDzzus8R8elkE65BKdFNdmIYXGMrnU7bBbi/XQfVTg4RAqSU+LP585pbrBaQ3OvAg2B2CkgxWa7nNMN996qXUqTAyAv+VL0IgBMwrLYAqDnBt1SDMz0rMfc/dUWxczr4VNkZ8NZGa1iYpQHPzosw+rTmRPIaq32jXNDBdk4jwRJ/iNL7ARmpZ/sfSDltkE8ZgLg0/xbU7lW4g8h4Aq4HdBzgft51SDajU221KYE2zoMuZ2UPePUASSaFwo0DQamiifoTMUmS2gs0wO9qJOwgakuc4mpJJz0WrIFBAyj6Jl/t3JsrvBZmBUqKgypJDf5OHEaxNQFOJiw0xMuPCCOQn2V4OE1om+1+6tIU8iwzRzhWYA91DWurWtzdaNaSJMctB8phx6ZxE7DcKpjkmpBudEAXzJ9+uXVS1pgzQRFczoE3EioAgXJy5b/KnCzcfUYp1NAro2mm01phH+MTFToNOZVOk7je9BshhuJhJw1nY1g8k9mF4Y3DoFOFEGRNb8hSO/umBspc+GiBrA1rEq3gXu/kbC1zYE8M0333TGJFCZgXaLndZumAL06clrhtAnI5R7qaRJSf6HN/8AIP8AqfOqF0fvnc/+oSTnwXy5+EJxBdJsKCT6ieghW54NOJoGnFc7qD6RAvW3a+Q8yVYeFJEAAAfN5nzusuDE3kRLWih4nRkSWid8yoZhgAQ2tz+TmtHtgG3LIlBaA2p0pHel1Im//Aayk2n4UYhAbOeufRaOI3gZERcpugkTEDLklMeWeJlitLWTUyFLMEDIB3b46qv1eKXGLD6aKwTE652VWlkK22waDYmZ008lPhzQXCwuc/NlJyp7e6BngbyIiKxJOdeaBSsk5CuX0QRJ++al5tYyTQZDXqr0DKAmvwkWZH3tunwbwM03Wtf2VRawS0ySaVORtoOgCbjepmsxfvkqEqXaeQoynU0DgQQBSbzU0TLQG1dy1Kji9QMUAPv83QCbmpi8U8soY037G8kisNGZmXHY0gDkmxlqXr4EuA0kjrTWEYuJEzMnS/IU97K9IinuJoI5k2RwGsk84opY5wAkQVIBIPFz5DSPM0wo04y8Ng4hB/iDpzJ3NITeIEmhMWudAEmmG0F9dvys/VPFR0RHOOpIEoBVY8lcRINAJN50udISiSM2i9YnQTzVhoEDQe6MQTegiTyG30SaejJokk3ygWFVs8AAAUkgHfop46CGwJpxGCegsqcy0gcpQ2C7Rk90GBGmY7aqYcf8hl6frK0aKyaAQIHWBtmm54oAJJPTqU3orVVszfiOPpY0uOpoBlU2VfqW8IDSQSOEczIXRi/qSwX4RpOf1XL+2HO4ibWG5zIzUrt6Lk6tS4+jZruGTIp1/tLimc/Ya/VU4GtRTLdRtmZLjqonLRydfYoRx7E9EKL4BwUoNgTQX91WPjcIgR0zUNZiOiW3ND9eUKg1jKuc06AEGeazi+SWUQRw8IjicfUZ/wAeQzKGYGt5lxN53PeiljuIudcmsyOnnNaQIja33VlEmUJI/wCRVQ5w4+HaVRc7M8uX2UMkkgEab9+qVqjfi14Yw2qp29On3WTMJ80IMbflaBkRxeg7hTauzE+Lw6mON6eBDAMs0cLTZ1NdUy7eVGk6I3oj+MnQV0qbblIvAoDJioGWl0mO4qRDR3OUqgNNpmgOZHTLXzkoedAh5igie6bSQZN8lJQ1xzoXDlCKEuJAypyAidttkmvmTOwAuTryj5UB9xI5fJ5qZmNms1Ailzyn8KMIEjnWNyfp9FoMInKJzPL7JsxBExAAgD5JWb4JOuEO9IkXoAY317rRmGRBcYMTH1P2WWCHOdxOqBUCwEe2izx8XiJEcU5RRKVcF1qmn7jXfxJgGpvOtf7RNCZpPe6bnQAM4y+yNgJmpET1qkp4FiuJFqRQanyUmYZLnQDDYbsIFYpum/FmjScp1GibGUiw/M+dVaQPLLDc7DUbflQ4SawGjOa10vWPlGNi1gAuIzy5dvlQ0TJJk+wz9NOdf6Uk5WL3k0ww0ya35odElwExYf39ENkCAaXqs3VGfwmUOSaSaLw8pFZnlT3oU8NwcScwkGSSRWwvHS1qIc6Q4AVmPydkbLG11TJmHLuN3QXgeaLVsknhAI0NLaR5VMNFSToAI8pHykXkxkAd6nfT3U3RTqjE9tuIhv8AyXAdZzQ4x6ZaTAtWOZsgMrSDz88lQ27gK5Taul7CqQ45wXLv9z3QlwHbshUNfJlODTNIy5JM/TMFadknf6xXPrWOcK4mkWV9AqnsUSKkNbAjkM/iqtsE3BjS2l9fup4fLC6RcDNAefyFmB2PEENJLhympyCTWkCGgDqp4YsACq4c3dPukRuqIiPuk97mkVrqQCYvnZMt0WZZIa5x9+isdg4k11h/RTGCJcDJO2WWSbiReDewtoOfmiYipi1BujhOkHT6koHwgaIGnmtytIhtxXnKgc1LjNTYJlH2Zh8uIuAtsMG+yzBs1oFa0+VtiMgV6Dy6HuGeDUZz0JDaCBkLTutONwo13C0aCO8KcB14bn4SqbhzMnP6pc7FZ4qkOfc8Jjueu6prXECkDJoiw10VuuGiwqftyUMe48TuIj2pyVaieXUGIbNipMkGwDddapsbEzQZnUVOVlBdLwJmmWcLTgzc6BkDPwp4wXF5a9ktE2aa6/JVOdEmgFvN0OeMoPTMqWtmp6DePKq9skxNMNLrmYFJExU9Al+891yYGtZ6D7qnMtNGigE1JuSVciJcRHJXsFhyXwZNdUiIJqadvgq+GgrX2VF1TWmw8qpc7vpn1VaOMwbnX37wFLpMQIVFt5Klz5mlrmyUTG0AXyimXOl0sXE4QGz6nHsPKpYBcaio3FZyF6ixTwsNoLnGrjSPLBGKD0vYBkCJMTJM3N5JVMIOdBr58pAg1pfz+lQxA0RAppZToraE5wypOvl05yBhvv3sscX9Q0QTE2HM0otGP0IKYHLi9ropCOA+FCKh+XHyiWtM5AZfdWRRL90TSKZC55k28us34ebuIm8A05SVfYt+RGsC+Zz5ebqxSnWOnwm1lMhrp3uUE3oemaqZsEzVSXk1Oap7oJzimvRLDbTiNzWB7DtCfZMCaRZBZxcNDwtEDfc9Snw7JuNpJqckU01VUN7stMvLqXFTxCeU0k+SrwxNYVIZWVgUapvKH4oBpkJqZga+e6hokanfL8+ZqXlmllFskEFpAAuIlS5zSS65igy5oaNExwgEmTFIlMVM6HgniBjSp/qybnCzdKlQcRzvS1rWtHb8lMcQFOHeLncrJJQl1iBSbnL2HlVZZ6YBu4CtoBEqWkHWNyAP7Q/EqADxHRooK6nP7pFIHOPEQHOAFzMb8z+U3msVc4wBM01JKljR6nOJHlh5mtP3QBLQQfPxVD3gOm/8jPGMO4YFIEAd+lh/SbpoA62QFKnXJNlMoJ1iSTpJ5qiSCBIm4G+Z7RVRXLJcA2qLjqhrW+o3OZNvyliPBgRetc+WgoKpHdKxHRmRJy+ilsVpOefhTbhkmSYAoB/dzRU19xYZmKnYK6wTy6uxOJiBRZEjhgW+dc6qsSoPaseFUMIcMSK+H2ToG7X6H+67hAaeGZNAK/YKWtdHEXE6bqsVwgaCewplySxHVAzA8CEOM+MCe7hBlxpWJ8zSDTEwA3t3mpKlgBNZyJtSNVZcHOkF0Cgpc7ap0GgYwAyWgEiJiCBnByyCMTErDRItlTPmU+GJz3P0Rh4ES4jb3z8zRjYppNPzs5+F/wDs3oChdvA3MN6x90K+b/yH4cvK/gzIoYoMyBcqHsJedI1j+lpiv4RJyWYBEEulzgJ1AnUUCldg3/wfATeDsP4jXrumXlsBop1py0VYbJzgZDS9VH7jcqgUGmitmm7BsGc6m2fyhjCal0iFLmn/ABnrTstAyKcJJziwjspsxJrQNOeWQn6Ie4TJERNz3KGYD7uIaI8EXlZuY1o/kSb1HYAd0KNipNjwWiJsJnTOc0P/AFJceFoJ2H1OXVOGkcTnGNBZAxvSQwBrc4iT2V3YXFdNGfDww2RJ9TjfP0tGw+hWrpIrI6ZarHCdLjAK3IpJFMgft5dLwy4rDFw18oFniNAaGgVJJOdP6VseZmJPbtshrIlzqHIabq0TeKDnf4i+eg77SocJBAzPdWBWBX50TabkROSqOHklzBm0jYeeSqEg0pNBrHnygSN6dyfooiAYJLzebTpugE8QciTSYoBl/W6bxMQa6CR+eqbWBtJknMJOdvcxO2gCfaLQZ5EwZMAD+kB3DS9CeXW6Ij0gGcz8pkgH/wBSFAyBUBtpqeSoPANALmTHzqUMcIkaDLT8oY6BbIxSvNTJdAH0knkOYSa0gXHn1T4xahd7DfSkJNZJAB9o76Jo2MGsaImXZxl1U4r83m9mNv1j6d1Yi/ScunulBq4jYHyyvZPBLnExQNizQKDZP9oEniMRHFa5mg8yGq0FM4PdZ4cGrpM116+aIuME94KL6S0RNAIg+flIUz4b29R7m5nNMmvFbIbfn6pNIAnTwDc1+FQOyw8ZgH55rNwcSIPKltyfvmg1HnZPCBqA4xzj61/KpMk1NfwUcJmrjzP5Qk4t/wBWn3QrJv58fDJP6eoJcHVmAKADP+08LCNXG+v2Q9jhDSRJIBpatU3EmgsKAZkzUlVfkxWnljLiZAoBT/onPkEsMQJtFtAdtan2Q9oAiYRij+PFkJGVTYoRpzYNk3Mc5tf7JcIa1zsrDKdSm5/+IbvH1UubxcIkQL+apB1ZMQwO/kSSTYLVuA1tmknf7nMrTDdm0HbXWSm1pAoCT7DfdTbKtKEPw5IBAGwsm8iYnycvMk3P4Qc4uTmch3UYGHSTc3KuibyateWtkNB6woe55rxA6/YHw1TxHC2QvnJ05qXPsSI5G8ViflCXZTpI0wxAvBNTedmilFyhkk1JO31J2hbYgIbxOdUySs8CQ2YJBtIvulYVLTiZpxEekHmYr5dN7hNRPL6CycOiKCb/ACk0xVvf7IFJUT4n6GRH5urbNvAoETt7lNwkmaeZpYdjB8+UAcge/D1OaOVch90i2YFFBoARENtr5kpc8NO/KYlW51CcteSyw3yC8/xs0ZnV2wonomzRjpPE6sUFPsg1n3E15AaJAtERV2gBvz2+iRNJMmZqTblFkE1jBTM8qxAHeChovHKfmPPhAxD/AJEVtWtaR2UteXCGNMWDopuZNFD0mU4gUpPgUl2d1LWtB/k4gGKACTnGgTY5sU4i0ZUHxVNL41FOJNBAByzIFwNVQeReka+VKlrnOJsJAHIabK2muw1r/aICJFpM9afNhVIAkgAjUm5FssiddlL3yRAnT7xmrjhHCLm9LbUzUXZL2Wms+V/pWDJgd9kw0jXSPopI1Ia2JNfZNFPMezP9s/7Hu77oVcXPoD9kJyc/gvP9EO/UAERJM2F1eHTWczoNBvW6oEAy0RkDnyWhcP8AJor0n8LPJ+EdMbSJwWT6nRw6f7HQX9Pysw4PcXESR2G/4R+rxi6BECwiw2CMNl5cadADoNUSKsNlNB4aD1ONc+nwq4KioBFcki4xIoAIEZ7mclnxuoKSQDUxe1EpU1H0aOxD/kQAM/pCzfilw9ILt61J8hPDwi53qjgFZnIVn+1ocQFxguAFJBjsMzVGE8BxSk/BnisILGxBmXbaCdvurEwJMC9lHEOL+UfJ2oqaWf7Occ4S1AX7ngZuBa9elbWuhpAroDSKfhBgawlwyQ0XN9hmecIHDMv1B9ILifVYADX3oteP/o8iKeyy4+J8mzZAHll0YdfUfzHwPyEvCyCy8/RBbJgTNKeeVSe8AlsxBg/JC1/dDWlwEZCvdcuFRscJBdUuNq9ZQiucmrXSSQaK2xz8slGQAbOlYHbaOqHnJvm6dm2gIpWnLTRDgOnkqeExfqVL8NtpLidTQAXJikJMEn1yZ4WCjnf/AJbv8K3+r1cMCgbNABSCpJ4jP+LaNbFICpzeI1kwffb3QLWGytALT/8AbPoOqb3iRPQA5/VNsyOKoANrKOKTIHegjtbNSF6yTh4tHFrCRYl0G2g5nzNkvdowCAPT5TkmyYIBMC5dF+iZJqSaZV/FSj6BPCfYsIU1ApOuZOyt7zRoEVr9tlLP/GdyT8U+VbhoQOY/NE9lpUhlST30/pQ/HH8RLjo3X6c1Ya0iHOLgLtFGzoSLwp/+SKw0Rb0yI2kKXpB6QYZiTfIVyHzN1Qjl8/iqYxIAhjZysT3sFm/9SBPpFNvJUqyjmEVivAhoqT4TsEsGXQcgBB3rUfdDXuP+LQDV0VFLAyB2TIa6eKWn/kyOyehe60YPdgz6nEnP1IXTh/ocKL+yEfPj7MfL7/gnDd65iYBgZc1kxs3qczz00H2QhPk6cNr8mzcMzFDofLK8RsEAnyJ0vZCFh7MP969mWMQTw5Z/+IEnrktGR/rEyTXLIe3shCWbW/yY4jzBhxaC4NpyknekXVubwAAU3gE3y0zSQntEiQBU1/qq2w8OSQChCuWg8kP4GS50kg2FpWbMVx/jAkRMVEnnVCEzBpbOj9P+kgGlBvdVinhbxOpmAPZCFyTb5ZOPHkzmLCTL6gV4QaAZBbuidPdCFtjy0uXuD4wdgoLvewQhKOvLaM21NRQVPwFLsQVAHEbE2A2GZ0QhPkz0btimW2Wkb80A5846ZoQgu3+SWzAmpPyfjzq+Ggzkj5QhAeCMFp4QbAyegN41VOw5j49vCkhVZm/pX4NCBYdTqdBoFhjOMgRJdZNCUdH/ANDHIaG4Y9TjMmwnPoqw8GlKACn1tzQhPSMcsFPw55DT8pNiJNJPMwPqhCB3RvdNyY09ha6hzTMbzKEJRdo14jqUkIUfREf/2Q==",
      gloss: 10
    },
    {
      name: "sausage",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "data:image/jpeg;base64,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",
      gloss: 8
    },
    {
      name: "sun",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "data:image/jpeg;base64,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",
      gloss: 8
    },
    {
      name: "meatball",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "data:image/jpeg;base64,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",
      gloss: 10
    },
    {
      name: "meat",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "./assets/normalMaps/13060-normal.jpg",
      gloss: 8
    },
    {
      name: "playerTomato",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "https://media.discordapp.net/attachments/1034127032570871939/1074736073143488552/pan_with_beef_normalmap.png",
      gloss: 5
    },
    {
      name: "playerMeat",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "./assets/normalMaps/13060-normal.jpg",
      gloss: 5
    },
    {
      name: "playerLettuce",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "./assets/normalMaps/13060-normal.jpg",
      gloss: 5
    },
    {
      name: "whiteWood",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "./assets/normalMaps/13060-normal.jpg",
      gloss: 0
    },
    {
      name: "asphalt",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "./assets/normalMaps/13060-normal.jpg",
      gloss: 5
    },
    {
      name: "grass",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "./assets/normalMaps/13060-normal.jpg",
      gloss: 1
    },
    {
      name: "tree",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "./assets/normalMaps/13060-normal.jpg",
      gloss: 0
    },
    {
      name: "barnWood",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "./assets/normalMaps/13060-normal.jpg",
      gloss: 1
    },
    {
      name: "houseWood",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "./assets/normalMaps/13060-normal.jpg",
      gloss: 1
    },
    {
      name: "asparagus",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "./assets/normalMaps/flat.jpeg",
      gloss: 10
    },
    {
      name: "anchovy",
      url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSTvQrFPAcP14DaOSKKum5YSaAsmgthQIMksQ&usqp=CAU",
      normalMap: "./assets/normalMaps/flat.jpeg",
      gloss: 10
    }


  ],

  canvas: undefined,
  ctx: undefined,

  loadedImages: [],
  loadedNormalMaps: [],
  squareWidth: null,
  textureResolution: 64,
  normalMapResolution: 64,
  
  fogOpacity: 1, // decreases outside, increases inside
  fov: Math.PI / 3,


  settings: {

    particles: false,

    shadows: true,
    shadowMapResolution: 4096,
    shadowMapSmoothing: 0,

    specularLighting: true,
    directionalLighting: true,

    volumetricLighting: true,
    volumetricMapResolution: 512,
    volumetricSampleResolution: 150,

    volumetricMapSmoothing: 2,

    fogIntensity: 0.0275,

    fogColorR: 1.3,
    fogColorG: 1.05,
    fogColorB: .8,

    sunPosition: [-50, 100, 25],
    sunAnglePitch: Math.PI * (1 / 5),
    sunAngleYaw: Math.PI * (1 / 3),

    heaven: false,

    skybox: true,

    outlineResolution: 1024,

    maxParticles: 8192,
    maxParticleRows: 13,

  },





  initialize: function () {

    this.canvas = document.getElementById("canvas"),
    this.canvas.width = window.innerWidth // THESE HAVE TO BE SET BEFORE GL IS MADE
    this.canvas.height = window.innerHeight
    document.getElementById("effectsCanvas").width = window.innerWidth
    document.getElementById("effectsCanvas").height = window.innerHeight
    this.aspect = canvas.width / canvas.height
    this.gl = this.canvas.getContext("webgl")

    // load textures //

    this.textures = {}
    for (let i in this.textureInfo) {
      this.textures[this.textureInfo[i].name] = {
        url: this.textureInfo[i].url,
        normalMap: this.textureInfo[i].normalMap,
        gloss: this.textureInfo[i].gloss,
        index: i
      }
    }

    this.textureMap = this.gl.createTexture()
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.textureMap)

    this.normalMap = this.gl.createTexture()
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.normalMap)

    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]))

    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true)

    this.canvas = document.createElement("canvas")
    this.ctx = this.canvas.getContext("2d")
    //document.getElementById("lobby").appendChild(this.canvas)

    this.normalMapCanvas = document.createElement("canvas")
    this.normalMapCtx = this.normalMapCanvas.getContext("2d")

    this.squareWidth = 20//Math.round(Math.sqrt(Object.keys(this.textures).length) + .499999)

    for (let name in this.textures) {
      let image = new Image()
      image.width = this.textureResolution
      image.height = this.textureResolution
      //document.body.appendChild(image)
      image.crossOrigin = "anonymous"
      image.onload = () => {
        this.loadedImages[this.textures[name].index] = image
        if (this.loadedImages.length < this.textureInfo.length) return
        let loadedAll = true
        for (let j = 0; j < this.loadedImages.length; j++) if (this.loadedImages[j] == null) loadedAll = false
        if (loadedAll) this.mergeImages(this.gl, this.loadedImages, this.textureMap)
      }
      image.src = this.textures[name].url
    }

    for (let name in this.textures) {
      let image = new Image()
      image.width = this.normalMapResolution
      image.height = this.normalMapResolution
      //document.body.appendChild(image)
      image.crossOrigin = "anonymous"
      image.onload = () => {
        this.loadedNormalMaps[this.textures[name].index] = image
        if (this.loadedNormalMaps.length < this.textureInfo.length) return
        let loadedAll = true
        for (let j = 0; j < this.loadedNormalMaps.length; j++) if (this.loadedNormalMaps[j] == null) loadedAll = false
        if (loadedAll) this.mergeNormalMaps(this.gl, this.loadedNormalMaps, this.normalMap)
      }
      image.src = this.textures[name].normalMap
    }


  


    let resolution = 1024

    this.skyboxCanvas = document.createElement("canvas")
    this.skyboxCanvas.width = resolution
    this.skyboxCanvas.height = resolution
    this.skyboxCtx = this.skyboxCanvas.getContext("2d")

    this.skyboxCtx.imageSmoothingEnabled = false

    this.skyboxCtx.fillStyle = "rgb(" + (255 * 0.75) + ", " + (255 * 0.8) + ", " + (255 * 1) + ")"
    this.skyboxCtx.fillRect(0, 0, 64, 64)

    //document.body.appendChild(this.skyboxCanvas)

    this.skyboxTexture = this.gl.createTexture()
    this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, this.skyboxTexture)

    let skyboxImage = new Image()
    skyboxImage.crossOrigin = "anonymous"
    skyboxImage.onload = () => {

      this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, this.skyboxTexture)

      let width = skyboxImage.width
      let height = skyboxImage.height

      this.skyboxCtx.translate(resolution, resolution)
      this.skyboxCtx.scale(-1, -1)
      this.skyboxCtx.drawImage(skyboxImage, width * 0, height / 3, width / 4, height / 3, 0, 0, resolution, resolution)
      this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.skyboxCanvas)

      this.skyboxCtx.drawImage(skyboxImage, width * .5, height / 3, width / 4, height / 3, 0, 0, resolution, resolution)
      this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.skyboxCanvas)

      this.skyboxCtx.drawImage(skyboxImage, width * .25, height * 0, width / 4, height / 3, 0, 0, resolution, resolution)
      this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.skyboxCanvas)

      this.skyboxCtx.drawImage(skyboxImage, width * .25, height * 2 / 3, width / 4, height / 3, 0, 0, resolution, resolution)
      this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.skyboxCanvas)

      this.skyboxCtx.drawImage(skyboxImage, width * .25, height / 3, width / 4, height / 3, 0, 0, resolution, resolution)
      this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.skyboxCanvas)

      this.skyboxCtx.drawImage(skyboxImage, width * .75, height / 3, width / 4, height / 3, 0, 0, resolution, resolution)
      this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.skyboxCanvas)

      this.gl.generateMipmap(this.gl.TEXTURE_CUBE_MAP)

    }
    skyboxImage.src = "https://i.imgur.com/fAyaLtu.png"



    this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR)
    this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE)
    this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE)





    


    // make framebuffer for shadow map

    if (!this.gl.getExtension("WEBGL_depth_texture")) throw("no depth texture")

    this.depthTexture = this.gl.createTexture()

    this.gl.bindTexture(this.gl.TEXTURE_2D, this.depthTexture)
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.DEPTH_COMPONENT, this.settings.shadowMapResolution, this.settings.shadowMapResolution, 0, this.gl.DEPTH_COMPONENT, this.gl.UNSIGNED_INT, null)

    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE)

    this.unusedTexture = this.gl.createTexture()
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.unusedTexture)
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.settings.shadowMapResolution, this.settings.shadowMapResolution, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null)

    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE)

    this.depthFramebuffer = this.gl.createFramebuffer()
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.depthFramebuffer)
    this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.TEXTURE_2D, this.depthTexture, 0)


    this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.unusedTexture, 0)



    // make framebuffer for volumetric map

    this.volumetricMap = this.gl.createTexture()
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.volumetricMap)
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.settings.volumetricMapResolution, this.settings.volumetricMapResolution, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null)

    this.gl.generateMipmap(this.gl.TEXTURE_2D)

    this.volumetricFramebuffer = this.gl.createFramebuffer()
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.volumetricFramebuffer)

    this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.volumetricMap, 0)

    this.volumetricMapDepthBuffer = this.gl.createRenderbuffer()
    this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.volumetricMapDepthBuffer)

    this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, this.settings.volumetricMapResolution, this.settings.volumetricMapResolution)
    this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this.volumetricMapDepthBuffer)



    // make framebuffer for normals color map

    this.normalRenderMap = this.gl.createTexture()
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.normalRenderMap)
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.canvas.width, this.gl.canvas.height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null)

    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE)

    this.normalRenderFramebuffer = this.gl.createFramebuffer()
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.normalRenderFramebuffer)

    this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.normalRenderMap, 0)

    this.normalRenderMapDepthBuffer = this.gl.createRenderbuffer()
    this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.normalRenderMapDepthBuffer)

    this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, this.gl.canvas.width, this.gl.canvas.height)
    this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this.normalRenderMapDepthBuffer)



    // MAKE TEXTURE AND FRAMEBUFFER FOR PARTICLES

    this.particlesTexture0 = this.gl.createTexture()
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.particlesTexture0)
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.settings.maxParticles * 2, this.settings.maxParticleRows, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null)

    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE)

    this.particlesFramebuffer0 = this.gl.createFramebuffer()
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.particlesFramebuffer0)

    this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.particlesTexture0, 0)


    this.particlesTexture1 = this.gl.createTexture()
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.particlesTexture1)
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.settings.maxParticles * 2, this.settings.maxParticleRows, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null)

    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE)

    this.particlesFramebuffer1 = this.gl.createFramebuffer()
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.particlesFramebuffer1)

    this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.particlesTexture1, 0)

    this.useFirstParticleFramebuffer = true



    this.gl.clearDepth(1);
    this.gl.depthFunc(this.gl.LEQUAL);

    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA)
    this.gl.enable(this.gl.BLEND)

    this.gl.enable(this.gl.CULL_FACE)
    this.gl.enable(this.gl.DEPTH_TEST)

    this.initializeShaders()


  
  },

  initializeShaders() {

    let vertexShaderText = `
    precision mediump float;
  
    attribute vec4 vertPosition;
    attribute vec3 aVertNormal;
    attribute vec2 aTexCoord;
  
    uniform float uScale;
    uniform vec3 uOffset;
    uniform float uWalkCycle;
    uniform float uCrouchValue;
    uniform float uLean;
    uniform mat4 mMatrix;
    uniform mat4 mnMatrix;
    uniform vec2 uTextureLocation;
    uniform float uTextureMapWidth;

    uniform mat4 pMatrix;
    uniform mat4 tMatrix;
    uniform mat4 shadowMatrix;

    varying lowp vec2 vTextureCoord;
    varying lowp vec3 vNormal;
    varying lowp vec3 vPosition;
    ${this.settings.shadows ? `varying lowp vec4 vProjectedCoord;` : ``}
  
    void main() {

      vec4 modelPosition = vec4(vertPosition.xyz * uScale + uOffset, 1.0);

      vec4 position = modelPosition;
      vec3 normal = aVertNormal;

      if (uWalkCycle != 0.0 || uCrouchValue != 0.0 || uLean != 0.0) {
          
        float walk = sin(uWalkCycle) * (2.0 - modelPosition.y) * sin(modelPosition.x * 2.0);
        float walkY = modelPosition.y * (1.0 - (uCrouchValue / 2.0)) + modelPosition.y * sin(modelPosition.x * 2.0) * sin(uWalkCycle) * 0.025;
        float walkZ = modelPosition.z + 0.2 * walk;

        position.z = walkZ * cos(uLean * modelPosition.y / 3.0) - walkY * sin(uLean * modelPosition.y / 3.0);
        position.y = walkZ * sin(uLean * modelPosition.y / 3.0) + walkY * cos(uLean * modelPosition.y / 3.0);

        normal.z = aVertNormal.z * cos(uLean * modelPosition.y / 3.0) - aVertNormal.y * sin(uLean * modelPosition.y / 3.0);
        normal.y = aVertNormal.z * sin(uLean * modelPosition.y / 3.0) + aVertNormal.y * cos(uLean * modelPosition.y / 3.0);

      }
      position = mMatrix * position;
      normal = vec4(mnMatrix * vec4(normal, 1.0)).xyz;

      gl_Position = pMatrix * tMatrix * position;

  
      vTextureCoord = (aTexCoord + uTextureLocation) / uTextureMapWidth;
      vNormal = normal;
      vPosition = position.xyz;
      ${this.settings.shadows ? `vProjectedCoord = shadowMatrix * position;` : ``}
    }
    `

    let fragmentShaderText = `
    precision mediump float;

    varying lowp vec2 vTextureCoord;
    varying lowp vec3 vNormal;
    varying lowp vec3 vPosition;
    ${this.settings.shadows ? `varying lowp vec4 vProjectedCoord;` : ``}

    uniform sampler2D uSampler;
    uniform sampler2D uNormalMapSampler;
    uniform sampler2D uShadowSampler;
    uniform sampler2D uVolumetricSampler;
    uniform sampler2D uNormalRenderSampler;
    uniform vec3 cPosition;
    uniform vec3 lPosition;
    uniform float uGlossValue;
    uniform bool uShadowable;
    uniform float uFogOpacity;
    uniform vec3 uShadowDirection;
    uniform vec2 uCanvasDimensions;

    uniform mat4 nMatrix;

    mat3 sx = mat3(
      1.0, 2.0, 1.0,
      0.0, 0.0, 0.0,
      -1.0, -2.0, -1.0
    );

    mat3 sy = mat3(
      1.0, 0.0, -1.0,
      2.0, 0.0, -2.0,
      1.0, 0.0, -1.0
    );
  
    void main() {
      lowp vec4 normalMapTexelColor = texture2D(uNormalMapSampler, vTextureCoord) * -0.5 + 0.5;

      highp vec3 normal = normalize(vNormal${this.settings.specularLighting ? ` + normalMapTexelColor.rgb` : ``});
      ${this.settings.specularLighting ? `
      highp vec3 toLight = normalize(lPosition - vPosition);
      highp float light = dot(normal, toLight);

      highp vec3 toCameraDir = normalize(cPosition - vPosition);
      highp vec3 reflectedLightDir = reflect(-toLight, normal);
      highp float specularLight = pow(abs(dot(reflectedLightDir, toCameraDir)), uGlossValue) * uGlossValue * .1;
      //specularLight *= 1.25;
      specularLight -= mod(specularLight, .5);
      ` : ``}
      
      highp vec3 directionalVector = normalize(vec3(0.0, 0.5, 1.0));
      highp vec4 transformedNormal = nMatrix * vec4(normal, 1.0);
  
      highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);
      highp float lighting = 0.75 + 0.5 * directional;
      ${this.settings.shadows ? `
      //float inRange = float(vProjectedCoord.x >= 0.0 && vProjectedCoord.x <= 1.0 && vProjectedCoord.y >= 0.0 && vProjectedCoord.y <= 1.0 && vProjectedCoord.z >= 0.0 && vProjectedCoord.z <= 1.0);
      float inShadowValue = 0.0;
      float shadowable = float(uShadowable);

      float shadowTexelSize = 1.0 / ${this.settings.shadowMapResolution}.0;
      for (int i = -${this.settings.shadowMapSmoothing}; i <= ${this.settings.shadowMapSmoothing}; i++) {
        for (int j = -${this.settings.shadowMapSmoothing}; j <= ${this.settings.shadowMapSmoothing}; j++) {
          float inShadow = float(texture2D(uShadowSampler, vProjectedCoord.xy + vec2(i, j) * shadowTexelSize).r < vProjectedCoord.z - ${1.75 / this.settings.shadowMapResolution});
          inShadowValue += 1.0 - 0.375 * (inShadow * shadowable);
        }
      }

      inShadowValue /= ${Math.pow(this.settings.shadowMapSmoothing * 2 + 1, 2)}.0;

      if (dot(normal, uShadowDirection) > 0.0 && uShadowable) inShadowValue = 0.625;

      ` : ``}
      ${this.settings.volumetricLighting ? `
      vec3 fogColor = vec3(0.0, 0.0, 0.0);
      float volumetricTexelSize = 1.0 / ${this.settings.volumetricMapResolution}.0;
      for (int i = -${this.settings.volumetricMapSmoothing}; i <= ${this.settings.volumetricMapSmoothing}; i++) {
        for (int j = -${this.settings.volumetricMapSmoothing}; j <= ${this.settings.volumetricMapSmoothing}; j++) {
          fogColor += texture2D(uVolumetricSampler, vec2(gl_FragCoord.x, gl_FragCoord.y) / uCanvasDimensions + vec2(i, j) * volumetricTexelSize).rgb;
        }
      }

      fogColor /= ${Math.pow(this.settings.volumetricMapSmoothing * 2 + 1, 2)}.0;
      ` : ``}

      lowp vec4 texelColor = texture2D(uSampler, vTextureCoord);
      if (texelColor.a == 0.0) discard;


      vec3 gx;
      vec3 gy;
      for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
          gx += sx[i][j] * texture2D(uNormalRenderSampler, vec2(gl_FragCoord.x + float(i)-1.0, gl_FragCoord.y + float(j)-1.0) / uCanvasDimensions).rgb;
          gy += sy[i][j] * texture2D(uNormalRenderSampler, vec2(gl_FragCoord.x + float(i)-1.0, gl_FragCoord.y + float(j)-1.0) / uCanvasDimensions).rgb;
        }
      }


      float gx2;
      float gy2;
      for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
          gx2 += sx[i][j] * texture2D(uNormalRenderSampler, vec2(gl_FragCoord.x + float(i)-1.0, gl_FragCoord.y + float(j)-1.0) / uCanvasDimensions).a;
          gy2 += sy[i][j] * texture2D(uNormalRenderSampler, vec2(gl_FragCoord.x + float(i)-1.0, gl_FragCoord.y + float(j)-1.0) / uCanvasDimensions).a;
        }
      }

      float gMagnitude = sqrt(pow(length(gx), 2.0) + pow(length(gy), 2.0));
      float gMagnitude2 = sqrt(gx2 * gx2 + gy2 * gy2);
      bool isOutlined = (gMagnitude > 1000.0 / sqrt(uCanvasDimensions.y * uCanvasDimensions.x) || gMagnitude2 > 25.0 / sqrt(uCanvasDimensions.y * uCanvasDimensions.x));
      float outline = 1.0 - (float(isOutlined) * 0.55);

      vec4 fragColor = vec4(
        (texelColor.r * outline * lighting${this.settings.specularLighting ? ` + specularLight * 0.5` : ``})${this.settings.shadows ? ` * inShadowValue ` : ``}${this.settings.volumetricLighting ? ` + fogColor.r * ${this.settings.fogColorR} * uFogOpacity` : ` + .05 * ${this.settings.fogColorR}`}, 
        (texelColor.g * outline * lighting${this.settings.specularLighting ? ` + specularLight * 0.5` : ``})${this.settings.shadows ? ` * inShadowValue ` : ``}${this.settings.volumetricLighting ? ` + fogColor.g * ${this.settings.fogColorG} * uFogOpacity` : ` + .05 * ${this.settings.fogColorG}`}, 
        (texelColor.b * outline * lighting${this.settings.specularLighting ? ` + specularLight * 0.5` : ``})${this.settings.shadows ? ` * inShadowValue ` : ``}${this.settings.volumetricLighting ? ` + fogColor.b * ${this.settings.fogColorB} * uFogOpacity` : ` + .05 * ${this.settings.fogColorB}`}, 
        texelColor.a
      );

      gl_FragColor = fragColor;
    }
    `

    // (n): 0, 1, 2
    // (3, (2)): 1, 2
    // (5, (3)): 1, 4, 6
    // (x): ... , (2 ^ n) / x
    // pattern is (n + 1) / 2 long
    // pattern is divided by 2 ^ (2 ^ ((n + 1) / 2))
    // pow(2, pow(2, (n+1) / 2))
    // 1: 2, 3: 4, 5: 8, 7: 16

    // shaders //
    let vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER)
    let fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER)

    // program //
    this.program = this.gl.createProgram()

    // buffers //
    this.pointsBuffer = this.gl.createBuffer()
    this.normalsBuffer = this.gl.createBuffer()
    this.texCoordsBuffer = this.gl.createBuffer()


    this.gl.shaderSource(vertexShader, vertexShaderText)
    this.gl.shaderSource(fragmentShader, fragmentShaderText)

    this.gl.compileShader(vertexShader)
    this.gl.compileShader(fragmentShader)

    this.gl.attachShader(this.program, vertexShader)
    this.gl.attachShader(this.program, fragmentShader)
    this.gl.linkProgram(this.program)
    this.gl.validateProgram(this.program)

    if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) console.log(`Unable to initialize the shader program: ${this.gl.getProgramInfoLog(this.program)}`)
  

    let vSize = 3;

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.pointsBuffer);

    let posAttribLocation = this.gl.getAttribLocation(this.program, "vertPosition");
    this.gl.vertexAttribPointer(posAttribLocation, vSize, this.gl.FLOAT, false, vSize * Float32Array.BYTES_PER_ELEMENT, 0);
    this.gl.enableVertexAttribArray(posAttribLocation);


    let nSize = 3;

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.normalsBuffer);

    let pointNormalAttribLocation = this.gl.getAttribLocation(this.program, "aVertNormal");
    this.gl.vertexAttribPointer(pointNormalAttribLocation, nSize, this.gl.FLOAT, false, nSize * Float32Array.BYTES_PER_ELEMENT, 0);
    this.gl.enableVertexAttribArray(pointNormalAttribLocation);


    let txSize = 2;

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordsBuffer);

    let texCoordAttribLocation = this.gl.getAttribLocation(this.program, "aTexCoord");
    this.gl.vertexAttribPointer(texCoordAttribLocation, txSize, this.gl.FLOAT, false, txSize * Float32Array.BYTES_PER_ELEMENT, 0);
    this.gl.enableVertexAttribArray(texCoordAttribLocation);

    
    this.gl.useProgram(this.program)

    this.gl.uniform2fv(this.gl.getUniformLocation(this.program, "uCanvasDimensions"), new Float32Array([this.gl.canvas.width, this.gl.canvas.height]))


    
    this.skyboxVertexShaderText = `
    precision mediump float;
  
    attribute vec4 vertPosition;

    varying lowp vec4 vPosition;
  
    void main() {
      
      gl_Position = vertPosition;
      gl_Position.z = 1.0;

      vPosition = vertPosition;
    }
    `

    this.skyboxFragmentShaderText = `
    precision mediump float;

    uniform samplerCube skybox;
    uniform mat4 matrix;

    uniform sampler2D uVolumetricSampler;
    uniform float uFogOpacity;
    uniform vec2 uCanvasDimensions;
  
    varying lowp vec4 vPosition;
  
    void main() {

      vec4 texcoord = matrix * vPosition;


      vec3 fogColor = vec3(0.0, 0.0, 0.0);
      float volumetricTexelSize = 1.0 / ${this.settings.volumetricMapResolution}.0;
      for (int i = -${this.settings.volumetricMapSmoothing}; i <= ${this.settings.volumetricMapSmoothing}; i++) {
        for (int j = -${this.settings.volumetricMapSmoothing}; j <= ${this.settings.volumetricMapSmoothing}; j++) {
          fogColor += texture2D(uVolumetricSampler, vec2(gl_FragCoord.x, gl_FragCoord.y) / uCanvasDimensions + vec2(i, j) * volumetricTexelSize).rgb;
        }
      }

      fogColor /= ${Math.pow(this.settings.volumetricMapSmoothing * 2 + 1, 2)}.0;
      

      vec4 color = textureCube(skybox, texcoord.xyz);
      gl_FragColor = vec4(
        color.r${this.settings.volumetricLighting ? ` * 0.8 + fogColor.r * ${this.settings.fogColorR} * uFogOpacity` : ` + .05 * ${this.settings.fogColorR}`},
        color.g${this.settings.volumetricLighting ? ` * 0.8 + fogColor.g * ${this.settings.fogColorG} * uFogOpacity` : ` + .05 * ${this.settings.fogColorG}`},
        color.b${this.settings.volumetricLighting ? ` * 0.8 + fogColor.b * ${this.settings.fogColorB} * uFogOpacity` : ` + .05 * ${this.settings.fogColorB}`},
        1.0
      );
    }
    `
    
    // Make skybox program


    // shaders //
    this.skyboxVertexShader = this.gl.createShader(this.gl.VERTEX_SHADER)
    this.skyboxFragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER)

    // program //
    this.skyboxProgram = this.gl.createProgram()

    this.gl.shaderSource(this.skyboxVertexShader, this.skyboxVertexShaderText)
    this.gl.shaderSource(this.skyboxFragmentShader, this.skyboxFragmentShaderText)

    this.gl.compileShader(this.skyboxVertexShader)
    this.gl.compileShader(this.skyboxFragmentShader)

    this.gl.attachShader(this.skyboxProgram, this.skyboxVertexShader)
    this.gl.attachShader(this.skyboxProgram, this.skyboxFragmentShader)
    this.gl.linkProgram(this.skyboxProgram)
    this.gl.validateProgram(this.skyboxProgram)


    if (!this.gl.getProgramParameter(this.skyboxProgram, this.gl.LINK_STATUS)) console.log(`Unable to initialize the skybox shader program: ${this.gl.getProgramInfoLog(this.skyboxProgram)}`)
  

    this.gl.useProgram(this.skyboxProgram)

    this.gl.uniform2fv(this.gl.getUniformLocation(this.skyboxProgram, "uCanvasDimensions"), new Float32Array([this.gl.canvas.width, this.gl.canvas.height]))

    // Make shadow map program

    this.shadowVertexShaderText = `
    precision mediump float;
  
    attribute vec4 vertPosition;
  
    uniform float uScale;
    uniform vec3 uOffset;
    uniform float uWalkCycle;
    uniform float uCrouchValue;
    uniform float uLean;
    uniform mat4 mMatrix;
    uniform mat4 mnMatrix;

    uniform mat4 pMatrix;
    uniform mat4 tMatrix;

  
    void main() {

      vec4 modelPosition = vec4(vertPosition.xyz * uScale + uOffset, 1.0);

      vec4 position = modelPosition;

      if (uWalkCycle != 0.0 || uCrouchValue != 0.0 || uLean != 0.0) {
          
        float walk = sin(uWalkCycle) * (2.0 - modelPosition.y) * sin(modelPosition.x * 2.0);
        float walkY = modelPosition.y * (1.0 - (uCrouchValue / 2.0)) + modelPosition.y * sin(modelPosition.x * 2.0) * sin(uWalkCycle) * 0.025;
        float walkZ = modelPosition.z + 0.2 * walk;

        position.z = walkZ * cos(uLean * modelPosition.y / 3.0) - walkY * sin(uLean * modelPosition.y / 3.0);
        position.y = walkZ * sin(uLean * modelPosition.y / 3.0) + walkY * cos(uLean * modelPosition.y / 3.0);

      }

      gl_Position = pMatrix * tMatrix * mMatrix * position;

    }
    `

    this.shadowFragmentShaderText = `
    precision mediump float;
  
    void main() {
      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
    `

    // shaders //
    this.shadowVertexShader = this.gl.createShader(this.gl.VERTEX_SHADER)
    this.shadowFragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER)

    // program //
    this.shadowProgram = this.gl.createProgram()


    this.gl.shaderSource(this.shadowVertexShader, this.shadowVertexShaderText)
    this.gl.shaderSource(this.shadowFragmentShader, this.shadowFragmentShaderText)

    this.gl.compileShader(this.shadowVertexShader)
    this.gl.compileShader(this.shadowFragmentShader)

    this.gl.attachShader(this.shadowProgram, this.shadowVertexShader)
    this.gl.attachShader(this.shadowProgram, this.shadowFragmentShader)
    this.gl.linkProgram(this.shadowProgram)
    this.gl.validateProgram(this.shadowProgram)

    if (!this.gl.getProgramParameter(this.shadowProgram, this.gl.LINK_STATUS)) console.log(`Unable to initialize the shadow shader program: ${this.gl.getProgramInfoLog(this.shadowProgram)}`)
  
    let shadowVSize = 3;

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.pointsBuffer)

    let shadowPosAttribLocation = this.gl.getAttribLocation(this.shadowProgram, "vertPosition");
    this.gl.vertexAttribPointer(shadowPosAttribLocation, shadowVSize, this.gl.FLOAT, false, shadowVSize * Float32Array.BYTES_PER_ELEMENT, 0);
    this.gl.enableVertexAttribArray(shadowPosAttribLocation);

    
    // draw an extra square at the 
  
    this.volumetricVertexShaderText = `
    precision mediump float;
  
    attribute vec4 vertPosition;
  
    uniform float uScale;
    uniform vec3 uOffset;
    uniform float uWalkCycle;
    uniform float uCrouchValue;
    uniform float uLean;
    uniform mat4 mMatrix;
    uniform mat4 mnMatrix;

    uniform mat4 pMatrix;
    uniform mat4 tMatrix;

    varying lowp vec3 vPosition;

  
    void main() {
      vec4 modelPosition = vec4(vertPosition.xyz * uScale + uOffset, 1.0);
      vec4 position = modelPosition;

      if (uWalkCycle != 0.0 || uCrouchValue != 0.0 || uLean != 0.0) {
        float walk = sin(uWalkCycle) * (2.0 - modelPosition.y) * sin(modelPosition.x * 2.0);
        float walkY = modelPosition.y * (1.0 - (uCrouchValue / 2.0)) + modelPosition.y * sin(modelPosition.x * 2.0) * sin(uWalkCycle) * 0.025;
        float walkZ = modelPosition.z + 0.2 * walk;

        position.z = walkZ * cos(uLean * modelPosition.y / 3.0) - walkY * sin(uLean * modelPosition.y / 3.0);
        position.y = walkZ * sin(uLean * modelPosition.y / 3.0) + walkY * cos(uLean * modelPosition.y / 3.0);
      }
      gl_Position = pMatrix * tMatrix * mMatrix * position;

      vPosition = vec4(mMatrix * position).xyz;

    }
    `

    this.volumetricFragmentShaderText = `
    precision mediump float;

    uniform mat4 shadowMatrix;
    uniform sampler2D uShadowSampler;

    uniform vec3 cPosition;

    varying lowp vec3 vPosition;


    void main() {

      float brightness = 0.0;

      float distance = length(vPosition - cPosition);
      ${this.settings.shadows ? `
      for (float z = 0.0; z < 1.0; z += 1.0 / ${this.settings.volumetricSampleResolution}.0) {
        vec4 realWorldPosition = vec4(mix(vPosition, cPosition, z), 1.0);
  
        vec4 projectedCoord = shadowMatrix * realWorldPosition;
        bool inShadow = texture2D(uShadowSampler, projectedCoord.xy).r < projectedCoord.z - .0015;
        brightness += (1.0 - float(inShadow)) * distance * ${this.settings.fogIntensity};
      }
      brightness /= ${this.settings.volumetricSampleResolution}.0;
      ` : `
      brightness = distance * ${this.settings.fogIntensity};
      `}

      //vec3 color = vec3(brightness * .75, brightness * .5, brightness * .25);
      vec3 color = vec3(brightness, brightness, brightness);
      
      gl_FragColor = vec4(color, 1.0);

    }
    `


    // shaders //
    this.volumetricVertexShader = this.gl.createShader(this.gl.VERTEX_SHADER)
    this.volumetricFragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER)


    // program //
    this.volumetricProgram = this.gl.createProgram()


    this.gl.shaderSource(this.volumetricVertexShader, this.volumetricVertexShaderText)
    this.gl.shaderSource(this.volumetricFragmentShader, this.volumetricFragmentShaderText)

    this.gl.compileShader(this.volumetricVertexShader)
    this.gl.compileShader(this.volumetricFragmentShader)

    this.gl.attachShader(this.volumetricProgram, this.volumetricVertexShader)
    this.gl.attachShader(this.volumetricProgram, this.volumetricFragmentShader)
    this.gl.linkProgram(this.volumetricProgram)
    this.gl.validateProgram(this.volumetricProgram)


    if (!this.gl.getProgramParameter(this.volumetricProgram, this.gl.LINK_STATUS)) console.log(`Unable to initialize the volumetric shader program: ${this.gl.getProgramInfoLog(this.volumetricProgram)}`)
  

    this.normalRenderVertexShaderText = `precision mediump float;
  
    attribute vec4 vertPosition;
    attribute vec3 aVertNormal;
  
    uniform float uScale;
    uniform vec3 uOffset;
    uniform float uWalkCycle;
    uniform float uCrouchValue;
    uniform float uLean;
    uniform mat4 mMatrix;
    uniform mat4 mnMatrix;

    uniform mat4 pMatrix;
    uniform mat4 tMatrix;

    varying lowp vec3 vNormal;
  
    void main() {

      vec4 modelPosition = vec4(vertPosition.xyz * uScale + uOffset, 1.0);

      vec4 position = modelPosition;
      vec3 normal = aVertNormal;

      if (uWalkCycle != 0.0 || uCrouchValue != 0.0 || uLean != 0.0) {
          
        float walk = sin(uWalkCycle) * (2.0 - modelPosition.y) * sin(modelPosition.x * 2.0);
        float walkY = modelPosition.y * (1.0 - (uCrouchValue / 2.0)) + modelPosition.y * sin(modelPosition.x * 2.0) * sin(uWalkCycle) * 0.025;
        float walkZ = modelPosition.z + 0.2 * walk;

        position.z = walkZ * cos(uLean * modelPosition.y / 3.0) - walkY * sin(uLean * modelPosition.y / 3.0);
        position.y = walkZ * sin(uLean * modelPosition.y / 3.0) + walkY * cos(uLean * modelPosition.y / 3.0);

        normal.z = aVertNormal.z * cos(uLean * modelPosition.y / 3.0) - aVertNormal.y * sin(uLean * modelPosition.y / 3.0);
        normal.y = aVertNormal.z * sin(uLean * modelPosition.y / 3.0) + aVertNormal.y * cos(uLean * modelPosition.y / 3.0);

      }
      position = mMatrix * position;
      normal = vec4(mnMatrix * vec4(normal, 1.0)).xyz;

      gl_Position = pMatrix * tMatrix * position;
  
      vNormal = normal;

    }
    `

    this.normalRenderFragmentShaderText = `
    precision mediump float;

    varying lowp vec3 vNormal;

    void main() {
      gl_FragColor = vec4((normalize(vNormal) + 1.0) / 2.0, gl_FragCoord.z);
    }
    `


    // shaders //
    this.normalRenderVertexShader = this.gl.createShader(this.gl.VERTEX_SHADER)
    this.normalRenderFragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER)


    // program //
    this.normalRenderProgram = this.gl.createProgram()


    this.gl.shaderSource(this.normalRenderVertexShader, this.normalRenderVertexShaderText)
    this.gl.shaderSource(this.normalRenderFragmentShader, this.normalRenderFragmentShaderText)

    this.gl.compileShader(this.normalRenderVertexShader)
    this.gl.compileShader(this.normalRenderFragmentShader)

    this.gl.attachShader(this.normalRenderProgram, this.normalRenderVertexShader)
    this.gl.attachShader(this.normalRenderProgram, this.normalRenderFragmentShader)
    this.gl.linkProgram(this.normalRenderProgram)
    this.gl.validateProgram(this.normalRenderProgram)


    if (!this.gl.getProgramParameter(this.normalRenderProgram, this.gl.LINK_STATUS)) console.log(`Unable to initialize the normalRender shader program: ${this.gl.getProgramInfoLog(this.normalRenderProgram)}`)
  


    this.particleMovementVertexShaderText = `
    precision mediump float;

    attribute float index;

    uniform float vertexArrayLength;
    uniform float numRows;

    varying vec2 texCoord;
    varying float vertexID;
    varying float vVertexArrayLength;

  
    void main() {
      float rowIndex = mod(index, vertexArrayLength);
      float row = (index - rowIndex) / vertexArrayLength;
      texCoord = vec2((rowIndex + 0.5) / vertexArrayLength, (row + 0.5) / numRows);
      vertexID = rowIndex;
      vVertexArrayLength = vertexArrayLength;
      gl_Position = vec4(((rowIndex + 0.5) / vertexArrayLength) * 2.0 - 1.0, ((row + 1.0) / numRows) * 2.0 - 1.0, 0.0, 1.0);
      gl_PointSize = 1.0;
    }
    `

    this.particleMovementFragmentShaderText = `
    precision mediump float;

    uniform float deltaTime;

    uniform float batchSize;
    uniform float lifespan; // milliseconds
    uniform int primeParticles;
    uniform bool produceNewParticles;
    uniform int movementType;
    uniform vec3 emitterPositionChange;
    uniform vec3 emitterPosition;

    uniform sampler2D lastPositions;
    varying vec2 texCoord;
    varying float vertexID;
    varying float vVertexArrayLength;

    void main() {

      float bigOrSmall = mod(vertexID, 2.0); // 0 if big, 1 if small

      vec4 bigPosition = texture2D(lastPositions, vec2(texCoord.x - (bigOrSmall / vVertexArrayLength), texCoord.y));
      vec4 smallPosition = texture2D(lastPositions, vec2(texCoord.x + ((1.0 - bigOrSmall) / vVertexArrayLength), texCoord.y));
      
      vec4 lastPosition = bigPosition * 255.0 + smallPosition; // xyz are position, w is life countdown
      
      vec4 newPosition = vec4(lastPosition.xyz - 127.0, lastPosition.w - deltaTime * 256.0 / lifespan);

      bool alive = newPosition.w > 0.0;             // reset position to emitterPosition if !alive
      newPosition.w += 256.0 * (1.0 - float(alive)); // set lifespan to 1 if !alive (+1 if dead, +0 if alive)
      
      float lifeCycle = newPosition.w / 256.0;
      float relativeIndex = mod((vertexID - bigOrSmall) / 2.0, batchSize) / batchSize;
      // change position however you want
      if (primeParticles == 1) {
        // prime particles
        newPosition.y = -127.0;
        newPosition.w = relativeIndex * 255.0;
      }
      if (primeParticles == 2) {
        // prime particles
        newPosition.y = -127.0;
        newPosition.w = (sin(relativeIndex * 3.1415926 * 64.0) + 1.0) * 128.0;//mod(relativeIndex * 255.0 * 1982.0, 255.0);
      }
      if (movementType == 1) {
        float angle = relativeIndex * 2.0 * 3.1415926;
        newPosition.x += sin(angle) * .05;
        newPosition.z += cos(angle) * .05;
        newPosition.y += 0.05 * lifeCycle;
      }
      if (movementType == 2) {
        newPosition.xyz = newPosition.xyz * float(alive) + (produceNewParticles ? emitterPosition : vec3(0.0, -127, 0.0)) * float(!alive);

        float pitch = relativeIndex * 18.0 * 3.1415926;
        newPosition.y += cos(pitch) * .001 * deltaTime;
        float changeZ = sin(pitch) * .001 * deltaTime;

        float yaw = relativeIndex * 74.0 * 3.1415926;
        newPosition.z += (changeZ * sin(yaw));
        newPosition.x += (changeZ * cos(yaw));
        
        
      }
      if (movementType == 3) {
        float num = relativeIndex * batchSize;
        //vec3 respawnPosition = vec3(
          //(num - mod(num, pow(batchSize, 2.0/3.0))) / batchSize, 
          //(mod(num, pow(batchSize, 2.0/3.0)) - mod(num, pow(batchSize, 1.0/3.0))) / pow(batchSize, 2.0/3.0), 
          //mod(num, pow(batchSize, 1.0/3.0)) / pow(batchSize, 1.0/3.0));
        vec3 respawnPosition = vec3(
          (mod(num, batchSize) - mod(num, pow(batchSize, 0.5))) / batchSize, 
          0.51, 
          mod(num, pow(batchSize, 0.5)) / pow(batchSize, 0.5)
        );
        respawnPosition = (respawnPosition - 0.5) * 128.0;
        //respawnPosition.y = pow((respawnPosition.y + 128.0) * .005, 4.0);
        newPosition.xyz = newPosition.xyz * float(alive) + respawnPosition * float(!alive);

        float pitch = relativeIndex * 7422.0 * 3.1415926;
        newPosition.y += cos(pitch) * .0005 * deltaTime;
        float changeZ = sin(pitch) * .0005 * deltaTime;

        float yaw = relativeIndex * 12466.0 * 3.1415926;
        newPosition.z += (changeZ * sin(yaw));
        newPosition.x += (changeZ * cos(yaw));
        
        
      }

      newPosition.xyz += 127.0;

      
      gl_FragColor = ((floor(newPosition) / 255.0) * (1.0 - bigOrSmall)) + ((newPosition - floor(newPosition)) * bigOrSmall);
      

    }
    `


    this.particlesBuffer = this.gl.createBuffer()

    // shaders //
    this.particleMovementVertexShader = this.gl.createShader(this.gl.VERTEX_SHADER)
    this.particleMovementFragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER)


    // program //
    this.particleMovementProgram = this.gl.createProgram()


    this.gl.shaderSource(this.particleMovementVertexShader, this.particleMovementVertexShaderText)
    this.gl.shaderSource(this.particleMovementFragmentShader, this.particleMovementFragmentShaderText)

    this.gl.compileShader(this.particleMovementVertexShader)
    this.gl.compileShader(this.particleMovementFragmentShader)

    this.gl.attachShader(this.particleMovementProgram, this.particleMovementVertexShader)
    this.gl.attachShader(this.particleMovementProgram, this.particleMovementFragmentShader)
    this.gl.linkProgram(this.particleMovementProgram)
    this.gl.validateProgram(this.particleMovementProgram)


    if (!this.gl.getProgramParameter(this.particleMovementProgram, this.gl.LINK_STATUS)) console.log(`Unable to initialize the particleMovement shader program: ${this.gl.getProgramInfoLog(this.particleMovementProgram)}`)
  
    //let particleAttribLocation = this.gl.getAttribLocation(this.particleMovementProgram, "index");
    //this.gl.vertexAttribPointer(particleAttribLocation, 1, this.gl.FLOAT, false, Float32Array.BYTES_PER_ELEMENT, 0);
    //this.gl.enableVertexAttribArray(particleAttribLocation);

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particlesBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, ParticleEmitter.arrayBuffer1, this.gl.STATIC_DRAW);

    //let iPosAttribLocation = this.gl.getAttribLocation(this.particleMovementProgram, "index");
    //this.gl.vertexAttribPointer(iPosAttribLocation, 1, this.gl.FLOAT, false, 0, 0);
    //this.gl.enableVertexAttribArray(iPosAttribLocation);
    

    this.particleDrawVertexShaderText = `
    precision mediump float;

    attribute float index;

    uniform float vertexArrayLength;
    uniform float numRows;
    uniform sampler2D particlePositions;
    uniform float size;
    uniform int opacityType;

    uniform mat4 pMatrix;
    uniform mat4 tMatrix;

    varying float lifeCountdown;
  
    void main() {
      float rowIndex = mod(index, vertexArrayLength);
      float row = (index - rowIndex) / vertexArrayLength;
      vec4 positionBig = texture2D(particlePositions, vec2((rowIndex + 0.25) / vertexArrayLength, (row + 0.5) / numRows));
      vec4 positionSmall = texture2D(particlePositions, vec2((rowIndex + 0.75) / vertexArrayLength, (row + 0.5) / numRows));
      vec4 position = positionBig * 255.0 + positionSmall;
      position.xyz -= 127.0;
      //position.x += 20.0 * (rowIndex + 0.5) / 100.0;
      gl_Position = pMatrix * tMatrix * vec4(position.xyz, 1.0);
      vec4 orthoPosition = tMatrix * vec4(position.xyz, 1.0);
      gl_PointSize = size / abs(orthoPosition.z);
      if (opacityType == 0) lifeCountdown = position.w - 64.0;
      if (opacityType == 1) {
        lifeCountdown = (pow(sin(2.0 * 3.1415926 * position.w / 256.0), 2.0) - 0.75) * 256.0;
        lifeCountdown = lifeCountdown / abs(orthoPosition.z) * 8.0;
      }
    }
    `

    this.particleDrawFragmentShaderText = `
    precision mediump float;

    uniform vec3 color;

    varying float lifeCountdown;

    void main() {
      gl_FragColor = vec4(color, lifeCountdown / 256.0);
    }
    `


    this.particlesDrawBuffer = this.gl.createBuffer()

    // shaders //
    this.particleDrawVertexShader = this.gl.createShader(this.gl.VERTEX_SHADER)
    this.particleDrawFragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER)


    // program //
    this.particleDrawProgram = this.gl.createProgram()


    this.gl.shaderSource(this.particleDrawVertexShader, this.particleDrawVertexShaderText)
    this.gl.shaderSource(this.particleDrawFragmentShader, this.particleDrawFragmentShaderText)

    this.gl.compileShader(this.particleDrawVertexShader)
    this.gl.compileShader(this.particleDrawFragmentShader)

    this.gl.attachShader(this.particleDrawProgram, this.particleDrawVertexShader)
    this.gl.attachShader(this.particleDrawProgram, this.particleDrawFragmentShader)
    this.gl.linkProgram(this.particleDrawProgram)
    this.gl.validateProgram(this.particleDrawProgram)


    if (!this.gl.getProgramParameter(this.particleDrawProgram, this.gl.LINK_STATUS)) console.log(`Unable to initialize the particleDraw shader program: ${this.gl.getProgramInfoLog(this.particleDrawProgram)}`)
  
    //let particleAttribLocation = this.gl.getAttribLocation(this.particleDrawProgram, "index");
    //this.gl.vertexAttribPointer(particleAttribLocation, 1, this.gl.FLOAT, false, Float32Array.BYTES_PER_ELEMENT, 0);
    //this.gl.enableVertexAttribArray(particleAttribLocation);

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particlesDrawBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, ParticleEmitter.arrayBuffer0, this.gl.STATIC_DRAW);



  },

  loadTexture: (gl, texture, canvas) => {
    let textures = new Image()
    textures.onload = () => {

      gl.bindTexture(gl.TEXTURE_2D, texture)
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures)

      if (textures.width & (textures.width - 1) === 0 && textures.height & (textures.height - 1) === 0) {
        console.log("using mipmap")
        gl.generateMipmap(gl.TEXTURE_2D)
      }
      else {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)

      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)


    }
    textures.src = canvas.toDataURL()
  },

  mergeImages: (gl, loadedImages, texture) => {

    webgl.canvas.width = webgl.squareWidth * webgl.textureResolution
    webgl.canvas.height = webgl.squareWidth * webgl.textureResolution
    //document.body.appendChild(webgl.canvas)
    webgl.canvas.style.imageRendering = "pixelated"
    //ctx.scale(-1, 1)

    for (let i = 0; i < loadedImages.length; i++) {
      if (loadedImages[i] != null) {
        let yLocation = parseInt(i / webgl.squareWidth, 10)
        let xLocation = i - yLocation * webgl.squareWidth

        webgl.ctx.drawImage(
          loadedImages[i],
          xLocation * webgl.textureResolution, yLocation * webgl.textureResolution, webgl.textureResolution, webgl.textureResolution)
      }

    }
    webgl.ctx.restore()

    webgl.loadTexture(gl, texture, webgl.canvas)


  },

  
  mergeNormalMaps: (gl, loadedImages, texture) => {

    webgl.normalMapCanvas.width = webgl.squareWidth * webgl.normalMapResolution
    webgl.normalMapCanvas.height = webgl.squareWidth * webgl.normalMapResolution
    //document.body.appendChild(webgl.normalMapCanvas)
    webgl.normalMapCanvas.style.imageRendering = "pixelated"
    //normalMapCtx.scale(-1, 1)

    for (let i = 0; i < loadedImages.length; i++) {
      if (loadedImages[i] != null) {
        let yLocation = parseInt(i / webgl.squareWidth, 10)
        let xLocation = i - yLocation * webgl.squareWidth

        webgl.normalMapCtx.drawImage(
          loadedImages[i],
          xLocation * webgl.normalMapResolution, yLocation * webgl.normalMapResolution, webgl.normalMapResolution, webgl.normalMapResolution)
      }

    }
    webgl.normalMapCtx.restore()

    webgl.loadTexture(gl, texture, webgl.normalMapCanvas)


  },

  updatePoints() {

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.pointsBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.points), this.gl.DYNAMIC_DRAW);

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.normalsBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.pointNormals), this.gl.DYNAMIC_DRAW);

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordsBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.texCoords), this.gl.DYNAMIC_DRAW);

    //this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particlesBuffer);
    //this.gl.bufferData(this.gl.ARRAY_BUFFER, ParticleEmitter.arrayBuffer0, this.gl.DYNAMIC_DRAW);

    //this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particlesDrawBuffer);
    //this.gl.bufferData(this.gl.ARRAY_BUFFER, ParticleEmitter.arrayBuffer0, this.gl.DYNAMIC_DRAW);

  },

  renderFrame: function (playerPosition, camera, cameraColliders, aimState, chargeValue, deltaTime) {

    this.updatePoints()

    // ---------- // Matrices

    let shadowTMatrix = mat4.create();

    this.settings.sunPosition = [0, 0, 75]
    vec3.rotateX(this.settings.sunPosition, this.settings.sunPosition, [0, 0, 0], -this.settings.sunAnglePitch)
    vec3.rotateY(this.settings.sunPosition, this.settings.sunPosition, [0, 0, 0], -this.settings.sunAngleYaw)

    mat4.rotateX(shadowTMatrix, shadowTMatrix, this.settings.sunAnglePitch);
    mat4.rotateY(shadowTMatrix, shadowTMatrix, this.settings.sunAngleYaw);
    mat4.translate(shadowTMatrix, shadowTMatrix, [-this.settings.sunPosition[0], -this.settings.sunPosition[1], -this.settings.sunPosition[2]]);

    let specularLightPosition = new Float32Array(this.settings.sunPosition)
    vec3.scale(specularLightPosition, this.settings.sunPosition, 10000)

    let shadowPMatrix = mat4.create();

    //                        fov        , aspect, near, far
    //mat4.perspective(shadowPMatrix, Math.PI / 2, 1, .1, 1000);
    mat4.ortho(shadowPMatrix, -80, 80, -80, 80, .1, 150)


    let tMatrix = mat4.create();


    let cameraPosition = [1.75, 1.5 + (.5 - (Math.cos(aimState * Math.PI) + 1) / 4), 8 * ((Math.cos(aimState * Math.PI) + 3) / 4)]
    vec3.rotateX(cameraPosition, cameraPosition, [0, 0, 0], -camera.position.lean)
    vec3.rotateY(cameraPosition, cameraPosition, [0, 0, 0], -camera.position.yaw)
    vec3.add(cameraPosition, cameraPosition, [playerPosition.x, playerPosition.y, playerPosition.z])
    
    let holdingWeaponPosition = [.25, 1.5, 0]
    vec3.rotateY(holdingWeaponPosition, holdingWeaponPosition, [0, 0, 0], -camera.position.yaw)
    vec3.add(holdingWeaponPosition, holdingWeaponPosition, [playerPosition.x, playerPosition.y, playerPosition.z])


    camera.lastPosition.x = holdingWeaponPosition[0]
    camera.lastPosition.y = holdingWeaponPosition[1]
    camera.lastPosition.z = holdingWeaponPosition[2]

    camera.position.x = cameraPosition[0]
    camera.position.y = cameraPosition[1]
    camera.position.z = cameraPosition[2]

    for (let i in cameraColliders) {
      if (cameraColliders[i] == null) continue
      let movement = camera.calculateSlopes()
      let collision = cameraColliders[i].collision(camera.lastPosition, camera.position, movement, camera.dimensions)

      if (collision.mx.intersects) {
        camera.position.x = collision.mx.x
        camera.position.y = collision.mx.y
        camera.position.z = collision.mx.z
      }
      if (collision.px.intersects) {
        camera.position.x = collision.px.x
        camera.position.y = collision.px.y
        camera.position.z = collision.px.z
      }

      if (collision.my.intersects) {
        camera.position.x = collision.my.x
        camera.position.y = collision.my.y
        camera.position.z = collision.my.z
      }
      if (collision.py.intersects) {
        camera.position.x = collision.py.x
        camera.position.y = collision.py.y
        camera.position.z = collision.py.z
      }

      if (collision.mz.intersects) {
        camera.position.x = collision.mz.x
        camera.position.y = collision.mz.y
        camera.position.z = collision.mz.z
      }
      if (collision.pz.intersects) {
        camera.position.x = collision.pz.x
        camera.position.y = collision.pz.y
        camera.position.z = collision.pz.z
      }
    }

    cameraPosition = [camera.position.x, camera.position.y, camera.position.z]





    mat4.rotateX(tMatrix, tMatrix, camera.position.lean);
    mat4.rotateY(tMatrix, tMatrix, camera.position.yaw);
    mat4.translate(tMatrix, tMatrix, [-cameraPosition[0], -cameraPosition[1], -cameraPosition[2]]);

    let fov = this.fov + chargeValue / 3

    let pMatrix = mat4.create();

    //                   fov        , aspect, near, far
    mat4.perspective(pMatrix, fov, this.aspect, .05, 1000);

    let shadowMatrix = mat4.create()
    mat4.scale(shadowMatrix, shadowMatrix, [0.5, 0.5, 0.5])
    mat4.translate(shadowMatrix, shadowMatrix, [1, 1, 1])
    mat4.multiply(shadowMatrix, shadowMatrix, shadowPMatrix)
    mat4.multiply(shadowMatrix, shadowMatrix, shadowTMatrix)


    let sMatrix = mat4.create();

    //                        fov        , aspect, near, far
    mat4.perspective(sMatrix, 1 / fov, this.aspect, .1, 1000);

    mat4.rotateY(sMatrix, sMatrix, camera.position.yaw / 1 + this.settings.sunAngleYaw - Math.PI);
    mat4.rotateX(sMatrix, sMatrix, camera.position.lean / 1);

    let npMatrix = mat4.create();

    //                   fov        , aspect, near, far
    mat4.perspective(npMatrix, fov, this.aspect, 1, 1000);


    
    // ---------------- RENDER SHADOW TEXTURE ---------------- //

    let vSize = 3;

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.pointsBuffer);

    let posAttribLocation = this.gl.getAttribLocation(this.program, "vertPosition");
    this.gl.vertexAttribPointer(posAttribLocation, vSize, this.gl.FLOAT, false, vSize * Float32Array.BYTES_PER_ELEMENT, 0);
    this.gl.enableVertexAttribArray(posAttribLocation);

    if (this.settings.shadows) {
      
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.depthFramebuffer)
      this.gl.viewport(0, 0, this.settings.shadowMapResolution, this.settings.shadowMapResolution)
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);


      this.gl.useProgram(this.shadowProgram);


      this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.shadowProgram, "tMatrix"), false, shadowTMatrix);
      this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.shadowProgram, "pMatrix"), false, shadowPMatrix);

      this.drawModels({
        mMatrix: this.gl.getUniformLocation(this.shadowProgram, "mMatrix"),
        walkCycle: this.gl.getUniformLocation(this.shadowProgram, "uWalkCycle"),
        crouchValue: this.gl.getUniformLocation(this.shadowProgram, "uCrouchValue"),
        lean: this.gl.getUniformLocation(this.shadowProgram, "uLean"),
        scale: this.gl.getUniformLocation(this.shadowProgram, "uScale"),
        offset: this.gl.getUniformLocation(this.shadowProgram, "uOffset")
      }, {
        endWithTransparent: true,
        excludeTransparentModels: true
      })
      
    }


    // ---------------- RENDER VOLUMETRIC TEXTURE ---------------- //


    if (this.settings.volumetricLighting) {
      
      this.gl.clearColor(1, 1, 1, 1);
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.volumetricFramebuffer)
      this.gl.viewport(0, 0, this.settings.volumetricMapResolution, this.settings.volumetricMapResolution)
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      

      this.gl.useProgram(this.volumetricProgram);


      this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.volumetricProgram, "tMatrix"), false, tMatrix);
      this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.volumetricProgram, "pMatrix"), false, pMatrix);
      this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.volumetricProgram, "shadowMatrix"), false, shadowMatrix);
      this.gl.uniform3fv(this.gl.getUniformLocation(this.volumetricProgram, "cPosition"), new Float32Array(cameraPosition));

      this.gl.activeTexture(this.gl.TEXTURE0)
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.depthTexture)
      this.gl.uniform1i(this.gl.getUniformLocation(this.volumetricProgram, "uShadowSampler"), 0)

      this.drawModels({
        mMatrix: this.gl.getUniformLocation(this.volumetricProgram, "mMatrix"),
        walkCycle: this.gl.getUniformLocation(this.volumetricProgram, "uWalkCycle"),
        crouchValue: this.gl.getUniformLocation(this.volumetricProgram, "uCrouchValue"),
        lean: this.gl.getUniformLocation(this.volumetricProgram, "uLean"),
        scale: this.gl.getUniformLocation(this.volumetricProgram, "uScale"),
        offset: this.gl.getUniformLocation(this.volumetricProgram, "uOffset")
      }, {
        endWithTransparent: true,
        excludeTransparentModels: true
      })

      this.calculateFogOpacity(deltaTime)

    }
    


    // ---------------- NORMAL RENDER ---------------- //

    this.gl.clearColor(1, 1, 1, 1);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.normalRenderFramebuffer)
    this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height)
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    
    this.gl.useProgram(this.normalRenderProgram);


    this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.normalRenderProgram, "tMatrix"), false, tMatrix);
    this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.normalRenderProgram, "pMatrix"), false, npMatrix);

    this.gl.disable(this.gl.BLEND)
    this.drawModels({
      mMatrix: this.gl.getUniformLocation(this.normalRenderProgram, "mMatrix"),
      mnMatrix: this.gl.getUniformLocation(this.normalRenderProgram, "mnMatrix"),
      walkCycle: this.gl.getUniformLocation(this.normalRenderProgram, "uWalkCycle"),
      crouchValue: this.gl.getUniformLocation(this.normalRenderProgram, "uCrouchValue"),
      lean: this.gl.getUniformLocation(this.normalRenderProgram, "uLean"),
      scale: this.gl.getUniformLocation(this.normalRenderProgram, "uScale"),
      offset: this.gl.getUniformLocation(this.normalRenderProgram, "uOffset")
    }, {
      endWithTransparent: true,
      excludeTransparentModels: true
    })
    this.gl.enable(this.gl.BLEND)


    // ---------------- SKYBOX RENDER ---------------- //

    if (!this.settings.volumetricLighting) this.gl.clearColor(0.75, 0.8, 1, 1);
    else this.gl.clearColor(
      0.75 + .6 * this.settings.fogColorR * this.fogOpacity, 
      0.8 + .6 * this.settings.fogColorG * this.fogOpacity, 
      1 + .6 * this.settings.fogColorB * this.fogOpacity, 
      1
    );
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null)
    this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height)
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);

    if (this.settings.skybox) {
      
      this.gl.useProgram(this.skyboxProgram);


      this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, this.skyboxTexture)
      this.gl.uniform1i(this.gl.getUniformLocation(this.skyboxProgram, "skybox"), 0)

      this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.skyboxProgram, "matrix"), false, sMatrix);
      this.gl.activeTexture(this.gl.TEXTURE1)
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.volumetricMap)
      this.gl.uniform1i(this.gl.getUniformLocation(this.skyboxProgram, "uVolumetricSampler"), 1)
      this.gl.uniform1f(this.gl.getUniformLocation(this.skyboxProgram, "uFogOpacity"), this.fogOpacity)

      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6)

    }



    // ---------------- FINAL RENDER ---------------- //

    this.gl.useProgram(this.program);


    this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.program, "tMatrix"), false, tMatrix);
    this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.program, "pMatrix"), false, pMatrix);



    let nMatrix = mat4.create();
    mat4.invert(nMatrix, tMatrix);
    mat4.transpose(nMatrix, nMatrix);

    this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.program, "nMatrix"), false, nMatrix);
    this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.program, "shadowMatrix"), false, shadowMatrix)


    this.gl.uniform3fv(this.gl.getUniformLocation(this.program, "lPosition"), specularLightPosition)
    this.gl.uniform3fv(this.gl.getUniformLocation(this.program, "cPosition"), new Float32Array(cameraPosition))
    this.gl.uniform1f(this.gl.getUniformLocation(this.program, "uFogOpacity"), this.fogOpacity)
    let shadowDirection = [0, 0, 1]
    vec3.rotateX(shadowDirection, shadowDirection, [0, 0, 0], this.settings.sunAnglePitch)
    vec3.rotateY(shadowDirection, shadowDirection, [0, 0, 0], this.settings.sunAngleYaw + Math.PI / 3)
    this.gl.uniform3fv(this.gl.getUniformLocation(this.program, "uShadowDirection"), new Float32Array(shadowDirection))

    this.gl.activeTexture(this.gl.TEXTURE0)
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.textureMap)//this.useFirstParticleFramebuffer ? this.particlesTexture1 : this.particlesTexture0)
    this.gl.uniform1i(this.gl.getUniformLocation(this.program, "uSampler"), 0)

    this.gl.activeTexture(this.gl.TEXTURE1)
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.normalMap)
    this.gl.uniform1i(this.gl.getUniformLocation(this.program, "uNormalMapSampler"), 1)

    this.gl.activeTexture(this.gl.TEXTURE2)
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.depthTexture)
    this.gl.uniform1i(this.gl.getUniformLocation(this.program, "uShadowSampler"), 2)

    this.gl.activeTexture(this.gl.TEXTURE3)
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.volumetricMap)
    this.gl.uniform1i(this.gl.getUniformLocation(this.program, "uVolumetricSampler"), 3)

    this.gl.activeTexture(this.gl.TEXTURE4)
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.normalRenderMap)
    this.gl.uniform1i(this.gl.getUniformLocation(this.program, "uNormalRenderSampler"), 4)
    
    this.gl.uniform1f(this.gl.getUniformLocation(this.program, "uTextureMapWidth"), this.squareWidth)

    if (!this.settings.heaven) this.drawModels({
      mMatrix: this.gl.getUniformLocation(this.program, "mMatrix"),
      mnMatrix: this.gl.getUniformLocation(this.program, "mnMatrix"),
      walkCycle: this.gl.getUniformLocation(this.program, "uWalkCycle"),
      crouchValue: this.gl.getUniformLocation(this.program, "uCrouchValue"),
      lean: this.gl.getUniformLocation(this.program, "uLean"),
      scale: this.gl.getUniformLocation(this.program, "uScale"),
      offset: this.gl.getUniformLocation(this.program, "uOffset"),
      glossValue: this.gl.getUniformLocation(this.program, "uGlossValue"),
      shadowable: this.gl.getUniformLocation(this.program, "uShadowable"),
      textureLocation: this.gl.getUniformLocation(this.program, "uTextureLocation")
    }, {
      endWithTransparent: true
    })
    


    // ---------------- MOVE PARTICLES ---------------- //

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particlesBuffer);

    this.gl.vertexAttribPointer(0, 1, this.gl.FLOAT, false, Float32Array.BYTES_PER_ELEMENT, 0);
    this.gl.enableVertexAttribArray(0);

    this.useFirstParticleFramebuffer = !this.useFirstParticleFramebuffer

    this.gl.clearColor(0, 0, 0, 1)
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.useFirstParticleFramebuffer ? this.particlesFramebuffer0 : this.particlesFramebuffer1)
    this.gl.viewport(0, 0, this.settings.maxParticles * 2, this.settings.maxParticleRows)
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT)

    this.gl.disable(this.gl.BLEND)
    
    this.gl.useProgram(this.particleMovementProgram);


    this.gl.uniform1f(this.gl.getUniformLocation(this.particleMovementProgram, "vertexArrayLength"), this.settings.maxParticles * 2);
    this.gl.uniform1f(this.gl.getUniformLocation(this.particleMovementProgram, "numRows"), this.settings.maxParticleRows);
    
    this.gl.uniform1f(this.gl.getUniformLocation(this.particleMovementProgram, "deltaTime"), deltaTime);

    this.gl.activeTexture(this.gl.TEXTURE0)
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.useFirstParticleFramebuffer ? this.particlesTexture1 : this.particlesTexture0)
    this.gl.uniform1i(this.gl.getUniformLocation(this.program, "lastPositions"), 0)


    for (let i in ParticleEmitter.allEmitters) ParticleEmitter.allEmitters[i].updateParticles(this.gl, this.particleMovementProgram)


    this.gl.enable(this.gl.BLEND)


    // ---------------- RENDER PARTICLES ---------------- //

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particlesDrawBuffer);

    this.gl.vertexAttribPointer(0, 1, this.gl.FLOAT, false, Float32Array.BYTES_PER_ELEMENT, 0);
    this.gl.enableVertexAttribArray(0);


    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null)
    this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height)
    
    this.gl.useProgram(this.particleDrawProgram);


    this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.particleDrawProgram, "tMatrix"), false, tMatrix);
    this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.particleDrawProgram, "pMatrix"), false, pMatrix);
    
    this.gl.uniform1f(this.gl.getUniformLocation(this.particleDrawProgram, "vertexArrayLength"), this.settings.maxParticles);
    this.gl.uniform1f(this.gl.getUniformLocation(this.particleDrawProgram, "numRows"), this.settings.maxParticleRows);

    this.gl.activeTexture(this.gl.TEXTURE0)
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.useFirstParticleFramebuffer ? this.particlesTexture0 : this.particlesTexture1)
    this.gl.uniform1i(this.gl.getUniformLocation(this.program, "particlePositions"), 0)

    for (let i in ParticleEmitter.allEmitters) ParticleEmitter.allEmitters[i].drawParticles(this.gl, this.particleDrawProgram)



    // ---------------- CALCULATE COLLISION ---------------- //

    // make an array of collisions
    // use points buffer
    // make a framebuffer for every rigid body???

    // Organization:
      // all 





  },

  drawModels(locations, options) {

    let transparentModels = []

    for (let i in Model.allModels) {

      // all of these: yaw, lean, pitch, roll, x, y, z, walkCycle, crouchValue, slideValue, scale

      if ((options.endWithTransparent || options.excludeTransparentModels) && Model.allModels[i].transparent) {
        transparentModels.push(Model.allModels[i])
      }
      else {

        let parent = Model.allModels[i].parent

        if (parent && parent.alive === false) continue

        let mMatrix = mat4.create()
        let mnMatrix = mat4.create()

        if (parent.position) {
          mat4.translate(mMatrix, mMatrix, [parent.position.x, parent.position.y, parent.position.z]);
          mat4.rotateY(mMatrix, mMatrix, -parent.position.yaw || 0);
          mat4.rotateX(mMatrix, mMatrix, -parent.position.pitch || 0);
          mat4.rotateZ(mMatrix, mMatrix, -parent.position.roll || 0);

          mat4.rotateY(mnMatrix, mnMatrix, -parent.position.yaw || 0);
          mat4.rotateX(mnMatrix, mnMatrix, -parent.position.pitch || 0);
          mat4.rotateZ(mnMatrix, mnMatrix, -parent.position.roll || 0);
        }
        if (locations.mMatrix != null) this.gl.uniformMatrix4fv(locations.mMatrix, false, mMatrix);
        if (locations.mnMatrix) this.gl.uniformMatrix4fv(locations.mnMatrix, false, mnMatrix);

        if (locations.walkCycle) this.gl.uniform1f(locations.walkCycle, parent.state ? parent.state.walkCycle : 0)
        if (locations.crouchValue) this.gl.uniform1f(locations.crouchValue, parent.state ? parent.state.crouchValue : 0)
        if (locations.lean) this.gl.uniform1f(locations.lean, parent.position ? parent.position.lean / 2 : 0)

        if (locations.scale) this.gl.uniform1f(locations.scale, Model.allModels[i].scale)
        if (locations.offset) this.gl.uniform3fv(locations.offset, new Float32Array([Model.allModels[i].offsetX, Model.allModels[i].offsetY, Model.allModels[i].offsetZ]))

        if (locations.glossValue) this.gl.uniform1f(locations.glossValue, Model.allModels[i].texture.gloss)
        if (locations.shadowable) this.gl.uniform1f(locations.shadowable, Model.allModels[i].shadowable)
        if (locations.textureLocation) this.gl.uniform2fv(locations.textureLocation, new Float32Array(Model.allModels[i].textureLocation))


        this.gl.drawArrays(
          this.gl.TRIANGLES, 
          Model.allModels[i].startIndex + Model.allModels[i].indexOffset, 
          Model.allModels[i].indexCount * 3
        )

      }

    }

    // draw transparent stuff

    if (!options.excludeTransparentModels) for (let i in transparentModels) {

      // all of these: yaw, lean, pitch, roll, x, y, z, walkCycle, crouchValue, slideValue, scale

      let parent = transparentModels[i].parent

      if (parent && parent.alive === false) continue

      let mMatrix = mat4.create()
      let mnMatrix = mat4.create()

      if (parent.position) {
        mat4.translate(mMatrix, mMatrix, [parent.position.x, parent.position.y, parent.position.z]);
        mat4.rotateY(mMatrix, mMatrix, -parent.position.yaw || 0);
        mat4.rotateX(mMatrix, mMatrix, -parent.position.pitch || 0);
        mat4.rotateZ(mMatrix, mMatrix, -parent.position.roll || 0);

        mat4.rotateY(mnMatrix, mnMatrix, -parent.position.yaw || 0);
        mat4.rotateX(mnMatrix, mnMatrix, -parent.position.pitch || 0);
        mat4.rotateZ(mnMatrix, mnMatrix, -parent.position.roll || 0);
      }
      if (locations.mMatrix != null) this.gl.uniformMatrix4fv(locations.mMatrix, false, mMatrix);
      if (locations.mnMatrix) this.gl.uniformMatrix4fv(locations.mnMatrix, false, mnMatrix);

      if (locations.walkCycle) this.gl.uniform1f(locations.walkCycle, parent.state ? parent.state.walkCycle : 0)
      if (locations.crouchValue) this.gl.uniform1f(locations.crouchValue, parent.state ? parent.state.crouchValue : 0)
      if (locations.lean) this.gl.uniform1f(locations.lean, parent.position ? parent.position.lean / 2 : 0)

      if (locations.scale) this.gl.uniform1f(locations.scale, transparentModels[i].scale)
      if (locations.offset) this.gl.uniform3fv(locations.offset, new Float32Array([transparentModels[i].offsetX, transparentModels[i].offsetY, transparentModels[i].offsetZ]))

      if (locations.glossValue) this.gl.uniform1f(locations.glossValue, transparentModels[i].texture.gloss)
      if (locations.shadowable) this.gl.uniform1f(locations.shadowable, transparentModels[i].shadowable)
      if (locations.textureLocation) this.gl.uniform2fv(locations.textureLocation, new Float32Array(transparentModels[i].textureLocation))


      this.gl.drawArrays(
        this.gl.TRIANGLES, 
        transparentModels[i].startIndex + transparentModels[i].indexOffset, 
        transparentModels[i].indexCount * 3
      )

    }


  },

  calculateFogOpacity(deltaTime) {


    this.gl.bindTexture(this.gl.TEXTURE_2D, this.volumetricMap)
    let averageColorPixels = new Uint8Array(Math.pow(this.settings.volumetricMapResolution, 2) * 4)
    this.gl.readPixels(0, 0, this.settings.volumetricMapResolution, this.settings.volumetricMapResolution, this.gl.RGBA, this.gl.UNSIGNED_BYTE, averageColorPixels)

    let sampleResolution = 32

    let brightness = 0
    for (let i = sampleResolution - 1; i >= sampleResolution / 2; i--) {
      for (let j = 0; j < sampleResolution; j++) {
        let xIndex = i * this.settings.volumetricMapResolution / sampleResolution
        let yIndex = j * this.settings.volumetricMapResolution / sampleResolution
        let index = 4 * Math.round(xIndex * this.settings.volumetricMapResolution + yIndex)
        brightness += averageColorPixels[index] + averageColorPixels[index + 1] + averageColorPixels[index + 2]
      }
    }

    brightness /= 3 * sampleResolution * (sampleResolution / 2)

    let timeToChange = 1000
    if (!isNaN(deltaTime)) this.fogOpacity = this.fogOpacity * (timeToChange - deltaTime) / timeToChange + (Math.pow(1 - brightness / 255, 2) + .2) * (10 / 12) * deltaTime / timeToChange

  }


}







class Point {
  static allPoints = []
  constructor(x, y, z, n1, n2, n3, r, g, b, tx1, tx2) {

    this.pointIndex = webgl.points.length / 3;

    webgl.points.push(x, y, z);
    webgl.pointNormals.push(n1, n2, n3)
    webgl.texCoords.push(tx1, tx2)

    webgl.pointCount++
  }f


  delete() {
    webgl.points.splice(this.pointIndex * 3, 3, null, null, null)
    webgl.pointColors.splice(this.pointIndex * 4, 4, null, null, null, null)
    webgl.pointNormals.splice(this.pointIndex * 3, 3, null, null, null)
  }


}






class Model {
  static allModels = []
  constructor(parent, geometryInfo, scale, texture, offsetX, offsetY, offsetZ, shadowable, transparent) {
    Model.allModels.push(this)
    this.parent = parent
    // 1 2 3

    // 1 2 3   1
    // 4 5 6   2
    // 7 8 9   3


    let squareWidth = webgl.squareWidth

    this.textureLocation = [0, 0]
    
    if (texture == null) {
      squareWidth = 1
      this.textureLocation[0] = 0
      this.textureLocation[1] = 0
      this.texture = {
        gloss: 0
      }
    }
    else {
      this.texture = webgl.textures[texture]

      this.textureLocation[1] = (squareWidth - 1) - (parseInt(this.texture.index / webgl.squareWidth, 10))
      this.textureLocation[0] = (this.texture.index - (parseInt(this.texture.index / webgl.squareWidth, 10)) * webgl.squareWidth)


    }


    this.scale = scale

    this.offsetX = offsetX || 0
    this.offsetY = offsetY || 0
    this.offsetZ = offsetZ || 0

    this.shadowable = shadowable
    if (this.shadowable == null) this.shadowable = 1.0

    this.transparent = transparent || false

    this.geometryInfo = geometryInfo

    this.indexOffset = 0

    this.startIndex = webgl.points.length / 3
    this.indexCount = geometryInfo.premadePointCount / 3

    webgl.points = webgl.points.concat(geometryInfo.premadePoints)
    webgl.pointNormals = webgl.pointNormals.concat(geometryInfo.premadeNormals)
    webgl.texCoords = webgl.texCoords.concat(geometryInfo.premadeTexcoords)

    webgl.pointCount += geometryInfo.premadePointCount * 3

    if (!geometryInfo.premadePoints) console.log(this)
    //console.log(geometryInfo.premadePoints.length, geometryInfo.premadePointCount)


    //heheheheheh goblin mdode


  }


  lerp(a, b, x) {
    return a + (b - a) * x
  }

  delete() {
    let allModelsLocation = Model.allModels.indexOf(this)

    if (allModelsLocation == -1) {
      console.log("this model has already been deleted")
      return
    }

    let deletedPoints = this.indexCount * 3

    webgl.points.splice((this.startIndex + this.indexOffset) * 3, deletedPoints * 3)
    webgl.pointNormals.splice((this.startIndex + this.indexOffset) * 3, deletedPoints * 3)
    webgl.texCoords.splice((this.startIndex + this.indexOffset) * 2, deletedPoints * 2)

    webgl.pointCount -= deletedPoints


    for (let i = Model.allModels.indexOf(this); i < Model.allModels.length; i++) {
      Model.allModels[i].indexOffset -= deletedPoints
    }
    Model.allModels.splice(Model.allModels.indexOf(this), 1)

    this.indexCount = 0
  }

}



class ParticleEmitter {
  // premade array buffers
  static arrayBuffer0 = new Float32Array(webgl.settings.maxParticles * webgl.settings.maxParticleRows)
  static arrayBuffer1 = new Float32Array(webgl.settings.maxParticles * 2 * webgl.settings.maxParticleRows)
  static nextAvailableIndex = []
  static allEmitters = []
  static availableIndexes = []

  constructor(position, row, options) {
    ParticleEmitter.allEmitters.push(this)
    this.row = row
    this.color = options.color || [1, 1, 1]
    this.size = options.size || 100
    this.movementType = options.type || 0
    this.lifespan = options.lifespan || 1000
    this.primeType = options.primeType || 0
    this.opacityType = options.opacityType || 0

    if (ParticleEmitter.availableIndexes[this.row].length > 0) {
      this.startIndex = ParticleEmitter.availableIndexes[this.row].splice(0, 1)[0] * Math.pow(2, this.row)
    }
    else {
      ParticleEmitter.nextAvailableIndex[this.row]++
      this.startIndex = ParticleEmitter.nextAvailableIndex[this.row] * Math.pow(2, this.row)
    }
    this.particleCount = Math.pow(2, this.row)
    this.functional = (this.startIndex + this.particleCount) <= webgl.settings.maxParticles
    
    this.position = position
    this.lastPosition = position

    this.unprimed = true
    this.producing = true
  }
  updateParticles(gl, particleMovementProgram) {
    if (!this.functional) return
    // update particle positions (run particle movement shader for particles in this emitters domain)
    gl.uniform1f(gl.getUniformLocation(particleMovementProgram, "batchSize"), this.particleCount);
    gl.uniform1f(gl.getUniformLocation(particleMovementProgram, "lifespan"), this.lifespan);
    gl.uniform1i(gl.getUniformLocation(particleMovementProgram, "primeParticles"), this.unprimed ? this.primeType : 0);
    gl.uniform1i(gl.getUniformLocation(particleMovementProgram, "produceNewParticles"), this.producing ? 1 : 0);
    gl.uniform1i(gl.getUniformLocation(particleMovementProgram, "movementType"), this.movementType);
    let positionChange = []
    vec3.sub(positionChange, this.position, this.lastPosition)
    gl.uniform3fv(gl.getUniformLocation(particleMovementProgram, "emitterPositionChange"), new Float32Array(positionChange));

    gl.uniform3fv(gl.getUniformLocation(particleMovementProgram, "emitterPosition"), new Float32Array(this.position));


    gl.drawArrays(
      gl.DOTS, 
      this.startIndex * 2 + (this.row * webgl.settings.maxParticles * 2), 
      this.particleCount * 2
    )

    if (this.unprimed) this.unprimed = false
    this.lastPosition = this.position
  }
  drawParticles(gl, particleDrawProgram) {
    if (!this.functional) return
    gl.uniform3fv(gl.getUniformLocation(particleDrawProgram, "color"), new Float32Array(this.color));
    gl.uniform1f(gl.getUniformLocation(particleDrawProgram, "size"), this.size);
    gl.uniform1i(gl.getUniformLocation(particleDrawProgram, "opacityType"), this.opacityType);

    gl.drawArrays(
      gl.DOTS, 
      this.startIndex + (this.row * webgl.settings.maxParticles), 
      this.particleCount
    )
  }
  remove() {
    this.producing = false
    window.setTimeout(() => {
        
      let index = ParticleEmitter.allEmitters.indexOf(this)
      if (index != -1) ParticleEmitter.allEmitters.splice(index, 1)

      if (!this.functional) return

      ParticleEmitter.availableIndexes[this.row].push(this.startIndex / Math.pow(2, this.row))
      ParticleEmitter.availableIndexes[this.row].sort((a, b) => {return b-a})
      for (let i = ParticleEmitter.availableIndexes[this.row].length - 1; i >= 1; i--) {
        if (ParticleEmitter.availableIndexes[this.row][i] == ParticleEmitter.availableIndexes[this.row][i-1]) ParticleEmitter.availableIndexes[this.row].splice(i, 1)
      }
    }, this.lifespan)
  }
}
for (let i = 0; i < ParticleEmitter.arrayBuffer0.length; i++) ParticleEmitter.arrayBuffer0[i] = i
for (let i = 0; i < ParticleEmitter.arrayBuffer1.length; i++) ParticleEmitter.arrayBuffer1[i] = i
for (let i = 0; i < webgl.settings.maxParticleRows; i++) ParticleEmitter.nextAvailableIndex.push(0)
for (let i = 0; i < webgl.settings.maxParticleRows; i++) ParticleEmitter.availableIndexes.push([])




class PhysicalObject {
  constructor(x, y, z, yaw, lean, dimensions, collisionType, collidableObjects) {
    this.position = { // world position
      x: x,
      y: y,
      z: z,
      yaw: yaw,
      lean: lean,
      pitch: 0,
      roll: 0
    }
    this.lastPosition = { // used for collision
      x: x,
      y: y,
      z: z,
      yaw: yaw,
      lean: lean,
      pitch: 0,
      roll: 0
    }
    this.serverPosition = { // updated in tick function
      x: x,
      y: y,
      z: z,
      yaw: yaw,
      lean: lean,
      pitch: 0,
      roll: 0
    }
    this.pastPositions = [ // optional use for smoothing
      {
        x: x,
        y: y,
        z: z,
        yaw: yaw,
        lean: lean,
        pitch: 0,
        roll: 0
      }
    ]
    // dimensions used for collision
    this.dimensions = dimensions

    this.collisionType = collisionType

    this.models = {}

    this.collidableObjects = collidableObjects || [] // ex. [platforms, players]






  }

  smoothPosition(currentTickStage) {
    this.position = {
      x: this.serverPosition.x + (this.serverPosition.x - this.lastPosition.x) * currentTickStage,
      y: this.serverPosition.y + (this.serverPosition.y - this.lastPosition.y) * currentTickStage,
      z: this.serverPosition.z + (this.serverPosition.z - this.lastPosition.z) * currentTickStage,
      yaw: this.serverPosition.yaw + (this.serverPosition.yaw - this.lastPosition.yaw) * currentTickStage,
      lean: this.serverPosition.lean + (this.serverPosition.lean - this.lastPosition.lean) * currentTickStage
    }

    this.state = {
      walkCycle: this.serverState.walkCycle + (this.serverState.walkCycle - this.lastState.walkCycle) * currentTickStage,
      crouchValue: this.serverState.crouchValue + (this.serverState.crouchValue - this.lastState.crouchValue) * currentTickStage,
      slideValue: this.serverState.slideValue + (this.serverState.slideValue - this.lastState.slideValue) * currentTickStage
    }

    this.pastPositions.splice(0, 0, this.position)
    this.pastPositions.splice(100)

    this.pastStates.splice(0, 0, this.state)
    this.pastStates.splice(100)

    let smoothing = 5
    if (smoothing > this.pastPositions.length) smoothing = this.pastPositions.length
    if (smoothing == 0) return

    let smoothedPosition = {
      x: 0,
      y: 0,
      z: 0,
      yaw: 0,
      lean: 0
    }
    let smoothedState = {
      walkCycle: 0,
      crouchValue: 0,
      slideValue: 0
    }
    for (let j = 0; j < smoothing; j++) {
      smoothedPosition.x += this.pastPositions[j].x / smoothing,
        smoothedPosition.y += this.pastPositions[j].y / smoothing,
        smoothedPosition.z += this.pastPositions[j].z / smoothing,
        smoothedPosition.yaw += this.pastPositions[j].yaw / smoothing,
        smoothedPosition.lean += this.pastPositions[j].lean / smoothing

      smoothedState.walkCycle += this.pastStates[j].walkCycle / smoothing
      smoothedState.crouchValue += this.pastStates[j].crouchValue / smoothing
      smoothedState.slideValue += this.pastStates[j].slideValue / smoothing
    }

    this.position = smoothedPosition
    this.state = smoothedState

  }

  clearSmoothing() {
    this.pastPositions = []
  }

  calculateSlopes() {
    // calculate 6 slopes

    let x1 = this.lastPosition.x
    let x2 = this.position.x
    let y1 = this.lastPosition.y
    let y2 = this.position.y
    let z1 = this.lastPosition.z
    let z2 = this.position.z


    let functions = {
      x: {
        dependY: function (y) { return ((x2 - x1) / (y2 - y1) * y + ((x2 - x1) / (y2 - y1) * -y1) + x1) },
        dependZ: function (z) { return ((x2 - x1) / (z2 - z1) * z + ((x2 - x1) / (z2 - z1) * -z1) + x1) }
      },
      y: {
        dependZ: function (z) { return ((y2 - y1) / (z2 - z1) * z + ((y2 - y1) / (z2 - z1) * -z1) + y1) },
        dependX: function (x) { return ((y2 - y1) / (x2 - x1) * x + ((y2 - y1) / (x2 - x1) * -x1) + y1) }
      },
      z: {
        dependX: function (x) { return ((z2 - z1) / (x2 - x1) * x + ((z2 - z1) / (x2 - x1) * -x1) + z1) },
        dependY: function (y) { return ((z2 - z1) / (y2 - y1) * y + ((z2 - z1) / (y2 - y1) * -y1) + z1) }
      }
    }



    return functions
  }

  collision(lastPosition, position, movement, dimensions) {
    if (dimensions == null) dimensions = {
      mx: 0,
      px: 0,
      my: 0,
      py: 0,
      mz: 0,
      pz: 0
    }

    let mx = this.position.x + this.dimensions.mx - dimensions.px
    let px = this.position.x + this.dimensions.px - dimensions.mx
    let my = this.position.y + this.dimensions.my - dimensions.py
    let py = this.position.y + this.dimensions.py - dimensions.my
    let mz = this.position.z + this.dimensions.mz - dimensions.pz
    let pz = this.position.z + this.dimensions.pz - dimensions.mz

    let collision = {
      mx: {
        intersects: false,
        y: movement.y.dependX(mx),
        z: movement.z.dependX(mx),
        x: mx
      },
      my: {
        intersects: false,
        z: movement.z.dependY(my),
        x: movement.x.dependY(my),
        y: my
      },
      mz: {
        intersects: false,
        x: movement.x.dependZ(mz),
        y: movement.y.dependZ(mz),
        z: mz
      },
      px: {
        intersects: false,
        y: movement.y.dependX(px),
        z: movement.z.dependX(px),
        x: px
      },
      py: {
        intersects: false,
        z: movement.z.dependY(py),
        x: movement.x.dependY(py),
        y: py
      },
      pz: {
        intersects: false,
        x: movement.x.dependZ(pz),
        y: movement.y.dependZ(pz),
        z: pz
      }
    }

    // calculate if intersection is within bounds of face and that the point has passed the face in the dependent direction
    if (lastPosition.x <= mx && mx <= position.x) {
      if (my < collision.mx.y && collision.mx.y < py && mz < collision.mx.z && collision.mx.z < pz) {
        collision.mx.intersects = true
      }
    }

    if (lastPosition.x >= px && px >= position.x) {
      if (my < collision.px.y && collision.px.y < py && mz < collision.px.z && collision.px.z < pz) {
        collision.px.intersects = true
      }
    }

    if (lastPosition.y <= my && my <= position.y) {
      if (mz < collision.my.z && collision.my.z < pz && mx < collision.my.x && collision.my.x < px) {
        collision.my.intersects = true
      }
    }

    if (lastPosition.y >= py && py >= position.y) {
      if (mz < collision.py.z && collision.py.z < pz && mx < collision.py.x && collision.py.x < px) {
        collision.py.intersects = true
      }
    }

    if (lastPosition.z <= mz && mz <= position.z) {
      if (mx < collision.mz.x && collision.mz.x < px && my < collision.mz.y && collision.mz.y < py) {
        collision.mz.intersects = true
      }
    }

    if (lastPosition.z >= pz && pz >= position.z) {
      if (mx < collision.pz.x && collision.pz.x < px && my < collision.pz.y && collision.pz.y < py) {
        collision.pz.intersects = true
      }
    }



    return collision
  }

  newCollision(parent, correctPosition, headBumpNoise) {
    let minDistance = this.dimensions.radius + parent.dimensions.radius + 1
    if (
      Math.abs(this.position.x - parent.position.x) > minDistance || 
      Math.abs(this.position.y - parent.position.y) > minDistance || 
      Math.abs(this.position.z - parent.position.z) > minDistance
    ) return false



    if (false && this.collisionType == "sphere" && parent.collisionType == "sphere") {
      // if distance between centers < radii combined, return colliding
      let distanceSquared = (
        Math.pow((parent.position.x + parent.dimensions.center[0]) - (this.position.x + this.dimensions.center[0]), 2) + 
        Math.pow((parent.position.y + parent.dimensions.center[1]) - (this.position.y + this.dimensions.center[1]), 2) + 
        Math.pow((parent.position.z + parent.dimensions.center[2]) - (this.position.z + this.dimensions.center[2]), 2)
      )
      return distanceSquared < Math.pow(parent.dimensions.radius + this.dimensions.radius, 2)
    }

    // this.collisionType can only be box

    let boxDimensions = [[], []]
    let colliding

    // this.dimensions should have: mx, px..., pitch, yaw, roll
    

    // sphere vs box collision

    let sphereCenter = [
      parent.position.x + parent.dimensions.center[0],
      parent.position.y + parent.dimensions.center[1],
      parent.position.z + parent.dimensions.center[2]
    ]
    
    // rotate centerpoint about sphere center
    let centerPointPosition = [
      this.position.x, 
      this.position.y, 
      this.position.z
    ]
    vec3.rotateY(centerPointPosition, centerPointPosition, sphereCenter, this.dimensions.yaw || this.position.yaw || 0)
    vec3.rotateX(centerPointPosition, centerPointPosition, sphereCenter, this.dimensions.pitch || this.position.pitch || 0)
    vec3.rotateZ(centerPointPosition, centerPointPosition, sphereCenter, this.dimensions.roll || this.position.roll || 0)


    boxDimensions[0][0] = centerPointPosition[0] + this.dimensions.mx
    boxDimensions[1][0] = centerPointPosition[0] + this.dimensions.px
    boxDimensions[0][1] = centerPointPosition[1] + this.dimensions.my
    boxDimensions[1][1] = centerPointPosition[1] + this.dimensions.py
    boxDimensions[0][2] = centerPointPosition[2] + this.dimensions.mz
    boxDimensions[1][2] = centerPointPosition[2] + this.dimensions.pz

    let closestPoint = [
      Math.max(boxDimensions[0][0], Math.min(sphereCenter[0], boxDimensions[1][0])),
      Math.max(boxDimensions[0][1], Math.min(sphereCenter[1], boxDimensions[1][1])),
      Math.max(boxDimensions[0][2], Math.min(sphereCenter[2], boxDimensions[1][2]))
    ]

    colliding = Math.sqrt(
      Math.pow(closestPoint[0] - sphereCenter[0], 2) + 
      Math.pow(closestPoint[1] - sphereCenter[1], 2) + 
      Math.pow(closestPoint[2] - sphereCenter[2], 2)
    ) < parent.dimensions.radius

    if (!correctPosition) return colliding

    if (colliding) {


      let closestSideDistance = 9999999999999999999
      let closestSide = 0
      for (let i = 0; i < 2; i++) {
        for (let j in boxDimensions[i]) {
          let distance = Math.abs(sphereCenter[j] - boxDimensions[i][j] + (-i*2+1) * parent.dimensions.radius)
          if (distance < closestSideDistance) {
            closestSideDistance = distance
            closestSide = j
          }
        }
      }

      let boundedAxes = [false, false, false]
      let boundedAxesCount = 0
      for (let i = 0; i < 3; i++) {
        if (boxDimensions[0][i] <= sphereCenter[i] && sphereCenter[i] < boxDimensions[1][i]) {
          boundedAxes[i] = true
          boundedAxesCount++
        }
      }

      let pointOnCircle = (radius, value) => {
        return Math.sqrt(Math.max(0, Math.min(Math.pow(radius, 2) - Math.pow(value, 2), Math.pow(radius, 2))))
      }

      let correctionVector = [0, 0, 0]

      if (boundedAxesCount >= 2) {
        // determine if sphere center is closer to m or p
        let direction
        if (sphereCenter[closestSide] < (boxDimensions[0][closestSide] + boxDimensions[1][closestSide]) / 2) direction = 0
        else direction = 1

        correctionVector[closestSide] = boxDimensions[direction][closestSide] + (direction*2-1) * parent.dimensions.radius - sphereCenter[closestSide]

      }
      else if (boundedAxesCount == 1) { // edge collision
        // find other 2 colliding coordinates
        let boundedAxis
        let unboundAxes = []
        for (let i = 0; i < 3; i++) if (!boundedAxes[i]) unboundAxes.push(i); else boundedAxis = i

        for (let i = 0; i < 2; i++) {
          let currentAxis = unboundAxes[i]
          let otherAxis = i ? unboundAxes[0] : unboundAxes[1]

          let direction // determine if sphere center is closer to m or p
          if (sphereCenter[currentAxis] < (boxDimensions[0][currentAxis] + boxDimensions[1][currentAxis]) / 2) direction = 0
          else direction = 1
          
          let otherDirection // determine if sphere center is closer to m or p
          if (sphereCenter[otherAxis] < (boxDimensions[0][otherAxis] + boxDimensions[1][otherAxis]) / 2) otherDirection = 0
          else otherDirection = 1


          if (otherAxis == closestSide) correctionVector[otherAxis] = (otherDirection*2-1) * pointOnCircle(parent.dimensions.radius, boxDimensions[direction][currentAxis] - sphereCenter[currentAxis]) - (sphereCenter[otherAxis] - boxDimensions[otherDirection][otherAxis])

        }
        
      }
      else if (boundedAxesCount == 0) { // corner collision
        // find closest corner

        let edgeDistances = []

        let direction // determine if sphere center is closer to m or p
        if (sphereCenter[closestSide] < (boxDimensions[0][closestSide] + boxDimensions[1][closestSide]) / 2) direction = 0
        else direction = 1

        for (let i = 0; i < 3; i++) {
          if (i != closestSide) {
            let direction // determine if sphere center is closer to m or p
            if (sphereCenter[i] < (boxDimensions[0][i] + boxDimensions[1][i]) / 2) direction = 0
            else direction = 1
            edgeDistances.push(boxDimensions[direction][i] - sphereCenter[i])
          }
          correctionVector[closestSide] = (direction*2-1) * pointOnCircle(parent.dimensions.radius, Math.sqrt(Math.pow(edgeDistances[0], 2) + Math.pow(edgeDistances[1], 2))) - (sphereCenter[closestSide] - boxDimensions[direction][closestSide])


        }
        




      }

      

      vec3.rotateZ(correctionVector, correctionVector, [0, 0, 0], -this.dimensions.roll || -this.position.roll || 0)
      vec3.rotateX(correctionVector, correctionVector, [0, 0, 0], -this.dimensions.pitch || -this.position.pitch || 0)
      vec3.rotateY(correctionVector, correctionVector, [0, 0, 0], -this.dimensions.yaw || -this.position.yaw || 0)
      
      parent.position.x += correctionVector[0]
      parent.position.y += correctionVector[1]
      parent.position.z += correctionVector[2]

      vec3.normalize(correctionVector, correctionVector)
      parent.velocity.x *= Math.sqrt(1 - Math.abs(correctionVector[0]))
      parent.velocity.y *= Math.sqrt(1 - Math.abs(correctionVector[1]))
      parent.velocity.z *= Math.sqrt(1 - Math.abs(correctionVector[2]))

      if (correctionVector[1] > .1) parent.onGround = true
      if (headBumpNoise && correctionVector[1] < -.1) headBumpNoise.play()

    }
      
    return colliding
    
  }

  remove() {
    for (let modelName in this.models) {
      this.models[modelName].delete()
    }
  }

}



class GamerTag {
  static allGamerTags = []
  constructor(name) {
    GamerTag.allGamerTags.push(this)

    this.name = name
    this.alive = false

    this.geometryInfo = {
      positions: [
        [-.75, -.25, 0],
        [.75, -.25, 0],
        [.75, .375, 0],
        [-.75, .375, 0]
      ],

      normals: [
        [-0, -0, 1]
      ],

      texcoords: [
        [.01, 0],
        [.99, 0],
        [.99, .5],
        [.01, .5]
      ],

      smooth: false,
      material: undefined,

      indices: [
        {
          vertexes: [0, 1, 2],
          texcoords: [0, 1, 2],
          normals: [0, 0, 0]
        },
        {
          vertexes: [2, 3, 0],
          texcoords: [2, 3, 0],
          normals: [0, 0, 0]
        }
      ]
    }

    this.geometryInfo.premadePoints = []
    this.geometryInfo.premadeNormals = []
    this.geometryInfo.premadeTexcoords = []
    this.geometryInfo.premadePointCount = 0

    for (let i = 0; i < this.geometryInfo.indices.length; i++)  {
      for (let j = 0; j < 3; j++) {
          this.geometryInfo.premadePoints.push(this.geometryInfo.positions[this.geometryInfo.indices[i].vertexes[j]][0], this.geometryInfo.positions[this.geometryInfo.indices[i].vertexes[j]][1], this.geometryInfo.positions[this.geometryInfo.indices[i].vertexes[j]][2])
          this.geometryInfo.premadeNormals.push(this.geometryInfo.normals[this.geometryInfo.indices[i].normals[j]][0], this.geometryInfo.normals[this.geometryInfo.indices[i].normals[j]][1], this.geometryInfo.normals[this.geometryInfo.indices[i].normals[j]][2])
          this.geometryInfo.premadeTexcoords.push(this.geometryInfo.texcoords[this.geometryInfo.indices[i].texcoords[j]][0], this.geometryInfo.texcoords[this.geometryInfo.indices[i].texcoords[j]][1])

          this.geometryInfo.premadePointCount++
      }

  }

    this.textureIndex = webgl.textureInfo.length
    webgl.textureInfo.length++

    webgl.textures[this.name] = {
      index: this.textureIndex,
      gloss: 0
    }
    let yLocation = parseInt(this.textureIndex / webgl.squareWidth, 10)
    let xLocation = this.textureIndex - yLocation * webgl.squareWidth
    webgl.ctx.clearRect(xLocation * webgl.textureResolution, yLocation * webgl.textureResolution, webgl.textureResolution, webgl.textureResolution)
    webgl.ctx.font = "32px VT323"

    let nameWidth = webgl.ctx.measureText(this.name).width
    webgl.ctx.fillStyle = "yellow"//"rgb(240, 215, 160)"
    webgl.ctx.fillText(this.name, xLocation * webgl.textureResolution + ((nameWidth < webgl.textureResolution) ? ((webgl.textureResolution - 1 - nameWidth) / 2) : 1), yLocation * webgl.textureResolution + webgl.textureResolution - 5, webgl.textureResolution - webgl.textureResolution / 32)




    webgl.loadTexture(webgl.gl, webgl.textureMap, webgl.canvas)

    this.position = {
      x: 0,
      y: 0,
      z: 0,
      yaw: 0,
      lean: 0,
      pitch: 0,
      roll: 0
    }

    this.model = new Model(this, this.geometryInfo, 1, this.name, 0, 0, 0, 0, true)
  }


  changeName(newName) {

    delete webgl.textures[this.name]
    this.name = newName
    webgl.textures[this.name] = {
      index: this.textureIndex,
      gloss: 0
    }
    let yLocation = parseInt(this.textureIndex / webgl.squareWidth, 10)
    let xLocation = this.textureIndex - yLocation * webgl.squareWidth
    webgl.ctx.clearRect(xLocation * webgl.textureResolution, yLocation * webgl.textureResolution, webgl.textureResolution, webgl.textureResolution)
    webgl.ctx.font = "32px VT323"

    let nameWidth = webgl.ctx.measureText(this.name).width
    webgl.ctx.fillStyle = "yellow"//"rgb(240, 215, 160)"
    webgl.ctx.fillText(this.name, xLocation * webgl.textureResolution + ((nameWidth < webgl.textureResolution) ? ((webgl.textureResolution - 1 - nameWidth) / 2) : 1), yLocation * webgl.textureResolution + webgl.textureResolution - 5, webgl.textureResolution - webgl.textureResolution / 32)




    webgl.loadTexture(webgl.gl, webgl.textureMap, webgl.canvas)

  }

}


class Particle extends PhysicalObject {
  static allParticles = []
  constructor(texture, x, y, z, movementVector, lifeSpan, collidableObjects) {
    super(x, y, z, 0, 0, { mx: -.1, px: .1, my: -.1, py: .1, mz: -.1, pz: .1 }, "none", collidableObjects)
    Particle.allParticles.push(this)

    this.texture = texture

    this.startTime = Date.now()
    this.lifeSpan = lifeSpan

    this.movementVector = movementVector

    this.geometryInfo = {
      positions: [
        [(Math.random() - .5) / 3, (Math.random() - .5) / 5, (Math.random() - .5) / 2],
        [(Math.random() - .5) / 1, (Math.random() - .5) / 3, (Math.random() - .5) / 3],
        [(Math.random() - .5) / 1, (Math.random() - .5) / 2, (Math.random() - .5) / 1],
        [(Math.random() - .5) / 2, (Math.random() - .5) / 1, (Math.random() - .5) / 1]
      ],
      normals: [
        [Math.random(), Math.random(), Math.random()]
      ],
      texcoords: [
        [0.1, 0.1],
        [0.9, 0.1],
        [0.9, 0.9]
      ],
      smooth: false,
      material: undefined,
      indices: [
        {
          vertexes: [0, 1, 2],
          texcoords: [0, 1, 2],
          normals: [0, 0, 0]
        },
        {
          vertexes: [3, 0, 1],
          texcoords: [0, 1, 2],
          normals: [0, 0, 0]
        },
        {
          vertexes: [3, 2, 1],
          texcoords: [0, 1, 2],
          normals: [0, 0, 0]
        }
      ]
    }

    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 3; j++) {
        this.geometryInfo.positions[i][j] /= 1.5
      }
    }

    this.models.main = new Model(this, this.geometryInfo, 1, this.texture, 0, 0, 0)

  }

  updateWorldPosition(deltaTime) {
    this.position.x += this.movementVector.x * deltaTime * .0025
    this.position.y += this.movementVector.y * deltaTime * .0025
    this.position.z += this.movementVector.z * deltaTime * .0025

    this.models.main.scale = Math.sin(Math.sqrt((Date.now() - this.startTime) / this.lifeSpan) * Math.PI)
  }

  static updateParticles(deltaTime) {
    for (let i = Particle.allParticles.length - 1; i >= 0; i--) {
      if (Date.now() - Particle.allParticles[i].startTime > Particle.allParticles[i].lifeSpan) {
        Particle.allParticles[i].remove()
        Particle.allParticles.splice(i, 1)
      }
      else Particle.allParticles[i].updateWorldPosition(deltaTime)
    }
  }

}


class Player extends PhysicalObject {
  static walkingSpeed = .00875
  static crouchingSpeed = .0025
  static sprintingSpeed = .015
  static slidingSpeed = .01
  static crouchingFOV = Math.PI * 0.33333
  static walkingFOV = Math.PI * 0.33333
  static sprintingFOV = Math.PI * 0.4
  static slidingFOV = Math.PI * 0.4
  static fovShiftSpeed = .0025
  static gravity = .00003//1
  static jumpForce = 0.015//05

  constructor(geometries, x, y, z, yaw, lean, health, id, name, collidableObjects) {
    super(x, y, z, yaw, lean, {center: [0, 1, 0], radius: 1, mx: -1, px: 1, my: 0, py: 2, mz: -.25, pz: .25}, "sphere", collidableObjects)

    this.gamerTag = new GamerTag(name)



    this.geometries = geometries

    this.models.frontSlice = new Model(this, geometries.frontSlice, 1, "bread", 0, 1, .25, 0.0)
    this.models.lettuce = new Model(this, geometries.lettuce, 1, "playerLettuce", 0, 1, .1, 0.0)
    this.models.tomato = new Model(this, geometries.tomato, 1, "playerTomato", 0, 1, 0, 0.0)
    this.models.meat = new Model(this, geometries.meat, 1, "playerMeat", 0, 1, -.1, 0.0)
    this.models.backSlice = new Model(this, geometries.backSlice, 1, "bread", 0, 1, -.25, 0.0)

    // Stores this player's currently active weapons
    this.weapons = []
    this.currentWeaponType
    this.inventory = {}
    this.killCount = 0

    this.cooldownTimer = 0
    this.currentCooldown = 1

    this.startChargeTime = 0
    this.charging = false
    this.chargeValue = 0
    
    this.id = id
    this.alive = false
    this.name = name
    this.lastName = this.name

    this.health = health

    this.velocity = { x: 0, y: 0, z: 0 }
    this.lastVelocity = { x: 0, y: 0, z: 0 }
    this.onGround = true
    this.hittingHead = true
    this.movementState = "walking"

    this.slideCountown = 0
    this.state = {
      walkCycle: 0,
      crouchValue: 0,
      slideValue: 0
    }
    this.lastState = {
      walkCycle: 0,
      crouchValue: 0,
      slideValue: 0
    }
    this.serverState = {
      walkCycle: 0,
      crouchValue: 0,
      slideValue: 0
    }
    this.pastStates = [
      {
        walkCycle: 0,
        crouchValue: 0,
        slideValue: 0
      }
    ]


  }

  calculatePosition(deltaTime, headBumpNoise) {
    this.lastVelocity = { x: this.velocity.x, y: this.velocity.y, z: this.velocity.z}

    this.velocity.y -= Player.gravity * deltaTime // subtract by gravitational constant (units/frames^2)





    this.onGround = false

    /*
    if (this.movementState == "walking" || this.movementState == "sprinting") this.dimensions = {
      mx: -.75,
      px: .75,
      my: 0,
      py: 2,
      mz: -.75,
      pz: .75
    }
    else if (this.movementState == "crouching" || this.movementState == "sliding") this.dimensions = {
      mx: -.75,
      px: .75,
      my: 0,
      py: 2,
      mz: -.75,
      pz: .75
    }
*/

    let velocityMagnitude = Math.hypot(this.velocity.x, this.velocity.y, this.velocity.z) * deltaTime

    let intermediateSteps = Math.ceil(velocityMagnitude / .25)

    if (intermediateSteps > 20) {
      this.velocity.x = 0
      this.velocity.y = 0
      this.velocity.z = 0
      return // return to avoid huge lag spikes
    }

    for (let i = 0; i < intermediateSteps; i++) {

      this.position.x += this.velocity.x * deltaTime / intermediateSteps
      this.position.y += this.velocity.y * deltaTime / intermediateSteps
      this.position.z += this.velocity.z * deltaTime / intermediateSteps
  

      // calculate collisions
      for (let i = 0; i < this.collidableObjects.length; i++) {
        for (let j in this.collidableObjects[i]) {
          if (this.collidableObjects[i][j] == null) continue
          if (this.collidableObjects[i][j] instanceof PhysicalObject) {
            if (this.collidableObjects[i][j] instanceof Player) this.collidableObjects[i][j].dimensions.py = 2 - this.collidableObjects[i][j].state.crouchValue
            if (this.collidableObjects[i][j] instanceof Player && !this.collidableObjects[i][j].alive) continue
            this.collidableObjects[i][j].newCollision(this, true, headBumpNoise)
          }
        }
      }
      
    }

  }

  updateCooldown(deltaTime) {
    if (isNaN(deltaTime)) deltaTime = 0
    this.cooldownTimer -= deltaTime / 1000
    if (this.cooldownTimer < 0) this.cooldownTimer = 0
  }




  remove() {
    super.remove()
    for (var i in this.weapons) {
      this.weapons[i].remove()
    }
    if (this.inventory.currentWeapon != null) this.inventory.currentWeapon.remove()
    this.gamerTag.model.delete()
  }
}


class Weapon extends PhysicalObject {
  static gravity = 0.00001
  static weaponSpecs
  constructor(geometryInfos, type, collidableObjects, owner, position) {
    super(position.x, position.y, position.z, 0, 0, { center: [0, 0, 0], radius: .5 }, "sphere", collidableObjects)
    this.position.pitch = position.pitch || 0
    this.position.yaw = position.yaw || 0
    this.position.roll = position.roll || 0

    //this.shootSoundEffect = new Audio("./assets/wet_wriggling_noises/breeze-of-blood-122253.mp3")
    //this.shootSoundEffect.currentTime = 0.25
    
    this.particleSpawnCounter = 0

    this.geometryInfos = geometryInfos
    this.type = type

    this.owner = owner
    this.alive = true

    let weaponSpec = Weapon.weaponSpecs[this.type]

    // default settings
    this.class = weaponSpec.variety
    this.texture = "jerry"

    this.cooldown = weaponSpec.cooldown / 1000 // seconds

    this.speed = weaponSpec.speed // units/millisecond
    this.manaCost = 20

    this.chargeTime = weaponSpec.chargeTime // milliseconds

    this.projectileCount = weaponSpec.projectileCount
    this.burstInterval = .5 // time between shots of bursts, seconds

    this.scale = 1


    switch (type) {
      case "tomato":
        this.texture = "tomato"

        this.scale = .625
        this.models.main = new Model(this, geometryInfos.tomato, this.scale, this.texture, 0, 0, 0, 0.0)
        break
      case "olive":
        this.texture = "olive"

        this.particleEmitter = new ParticleEmitter([position.x, position.y, position.z], 6, {color: [.4, .5, 0], size: 150, type: 2, lifespan: 1000, primeType: 1, opacityType: 0})

        this.scale = .35//.925
        this.models.main = new Model(this, geometryInfos.olive, this.scale, this.texture, 0, 0, 0, 0.0)
        break
      case "pickle":
        this.texture = "pickle"

        this.scale = .625
        this.models.main = new Model(this, geometryInfos.pickle, this.scale, this.texture, 0, 0, 0, 0.0)
        break
      case "sausage":
        this.texture = "sausage"

        this.scale = 1
        this.models.main = new Model(this, geometryInfos.sausage, this.scale, this.texture, 0, 0, 0, 0.0)
        break
      case "anchovy":
        this.texture = "anchovy"

        this.scale = .675
        this.models.main = new Model(this, geometryInfos.anchovy, this.scale, this.texture, 0, 0, 0, 0.0)
        break
      case "pan":
        this.texture = "meat"

        this.scale = .75
        this.models.main = new Model(this, geometryInfos.pan, this.scale, this.texture, 0, 0, -.5, 0.0)
        break
      case "meatball":
        this.texture = "meatball"

        this.scale = 1
        this.models.main = new Model(this, geometryInfos.meatball, this.scale, this.texture, 0, 0, 0, 0.0)
        break
      case "asparagus":
        this.texture = "asparagus"

        this.scale = 2
        this.models.main = new Model(this, geometryInfos.asparagus, this.scale, this.texture, 0, 0, 0, 0.0)
        break
        case "groundBeef":
          this.texture = "meat"
  
          this.particleEmitter = new ParticleEmitter([position.x, position.y, position.z], 4, {color: [.3, .1, 0], size: 75, type: 2, lifespan: 1000, primeType: 1, opacityType: 0})

          this.scale = .1
          this.models.main = new Model(this, geometryInfos.groundBeef, this.scale, this.texture, 0, 0, 0, 0.0)
          break
    }



    this.shooted = false
    this.velocity = {
      x: 0,
      y: 0,
      z: 0
    }

  }

  calculatePosition(deltaTime) {

    if (!this.shooted) {
      let distanceFromPlayer = 1.75 * (Math.cos(Math.PI * ((this.owner.currentCooldown - this.owner.cooldownTimer) / this.owner.currentCooldown - 1)) + 1) / 2
      let relativeYaw = 0
      let pitch = 0
      let relativeY = 1.5
      if (this.class == "flinger") {
        distanceFromPlayer = 1.75
        if (this.owner.cooldownTimer == 0) pitch = -this.owner.position.lean + this.owner.chargeValue * -Math.PI
        else pitch = -this.owner.position.lean + (1 - Math.cos(this.owner.cooldownTimer / this.cooldown * Math.PI / 2)) * -Math.PI / 2
        relativeYaw = Math.PI
        relativeY = 1
      }
      if (this.class == "projectile") {
        relativeYaw = Date.now() / 1000
      }
      if (this.class == "missile") {
        pitch = this.owner.position.lean
      }
      
      this.models.main.scale = this.scale * distanceFromPlayer / 1.75

      this.position.x = this.owner.position.x + Math.cos(this.owner.position.yaw) * distanceFromPlayer
      this.position.y = this.owner.position.y + relativeY
      this.position.z = this.owner.position.z + Math.sin(this.owner.position.yaw) * distanceFromPlayer

      this.position.yaw = this.owner.position.yaw + relativeYaw
      this.position.pitch = pitch
    }
    let rotateSpeed = ((!this.shooted ? this.owner.chargeValue : 1) / 2)
    //if (this.class == "projectile") this.position.yaw += (this.owner.lastPosition.yaw - this.owner.position.yaw)// + rotateSpeed
    if (this.class == "missile") this.position.roll += rotateSpeed


    this.lastPosition = { x: this.position.x, y: this.position.y, z: this.position.z, pitch: this.position.pitch, yaw: this.position.yaw, roll: this.position.roll }
    if (!this.shooted) return


    if (this.class == "projectile") this.velocity.y -= Weapon.gravity * deltaTime

    this.position.x += this.velocity.x * deltaTime
    this.position.y += this.velocity.y * deltaTime
    this.position.z += this.velocity.z * deltaTime
    
    if (this.particleEmitter) this.particleEmitter.position = [this.position.x, this.position.y, this.position.z]
    this.particleSpawnCounter++
    if (webgl.settings.particles && this.particleSpawnCounter % 2 == 0 && this.shooted) for (let i = 0; i < 1; i++) new Particle(this.texture, this.position.x, this.position.y, this.position.z, { x: Math.random() - .5, y: Math.random() - .5, z: Math.random() - .5 }, 1500, [])
    
  }




  remove() {
    super.remove()
    let ownerWeaponsIndex = this.owner.weapons.indexOf(this)
    if (ownerWeaponsIndex != -1) this.owner.weapons.splice(ownerWeaponsIndex, 1)
    if (this.particleEmitter) this.particleEmitter.remove()
  }


}



class Platform extends PhysicalObject {
  constructor(geometryInfo, type, x, y, z, scale) {
    super(x, y, z, 0, 0, { mx: 0, px: 0, my: 0, py: 0, mz: 0, pz: 0 }, "orientedBox")
    this.scale = scale || 1

    if (geometryInfo) {

      let positions = geometryInfo[type].positions
      for (let i = 0; i < positions.length; i++) {
        this.dimensions = {
          mx: (positions[i][0] * this.scale < this.dimensions.mx || i == 0) ? positions[i][0] * this.scale : this.dimensions.mx,
          px: (positions[i][0] * this.scale > this.dimensions.px || i == 0) ? positions[i][0] * this.scale : this.dimensions.px,
          my: (positions[i][1] * this.scale < this.dimensions.my || i == 0) ? positions[i][1] * this.scale : this.dimensions.my,
          py: (positions[i][1] * this.scale > this.dimensions.py || i == 0) ? positions[i][1] * this.scale : this.dimensions.py,
          mz: (positions[i][2] * this.scale < this.dimensions.mz || i == 0) ? positions[i][2] * this.scale : this.dimensions.mz,
          pz: (positions[i][2] * this.scale > this.dimensions.pz || i == 0) ? positions[i][2] * this.scale : this.dimensions.pz
        }
      }
    }




    this.texture = "olive" // default to olive texture

    if (type == "basic") {
      this.texture = "sub"
    }
    if (type == "crate") {
      this.texture = "wood"
    }
    if (type == "pinetree") {
      this.texture = "jerry"

      this.dimensions.mx = -.25 * this.scale
      this.dimensions.px = .25 * this.scale
      this.dimensions.mz = -.25 * this.scale
      this.dimensions.pz = .25 * this.scale

      //setInterval(() => {
      //  this.models.main.setPosition(0, Math.sin(Date.now() / 500) / 5, 0, 0, this.position.x, this.position.y - .1 * this.scale, this.position.z, geometryInfo[type], geometryInfo[type], 1)
      //}, 20)
    }

    if (geometryInfo) {
      this.models.main = new Model(this, geometryInfo[type], this.scale, this.texture)
    }
  }


}


class Ground {
  constructor(geometryInfo) {

    this.model = new Model(this, geometryInfo, 1, "jerry")

    let xValues = []
    let positions = geometryInfo.positions
    for (let i = 0; i < positions.length; i++) xValues.push(positions[i][0])

    xValues.sort((a, b) => { return a - b })
    this.xMin = xValues[0]

    //let xDifferenceTotal = 0
    let xDifferenceCount = 0
    for (let i = 0; i < xValues.length - 1; i++) {
      let difference = xValues[i + 1] - xValues[i]
      if (Math.abs(difference) > 0.1) {
        //xDifferenceTotal += difference
        xDifferenceCount++
      }
    }
    this.xWidth = (xValues[xValues.length - 1] - xValues[0]) / xDifferenceCount


    positions.sort((a, b) => { return a[0] - b[0] })
    let positionsMap = []
    let index = -1
    for (let i = 0; i < positions.length; i++) {
      if (i == 0 || (positions[i][0] - positions[i - 1][0]) > .1) {
        positionsMap.push([])
        index++
      }
      positionsMap[index].push(positions[i])
    }
    for (let i = 0; i < positionsMap.length; i++) positionsMap[i].sort((a, b) => { return a[2] - b[2] })
    this.zMin = positionsMap[0][0][2]

    this.heightMap = []
    for (let i = 0; i < positionsMap.length; i++) {
      this.heightMap.push([])
      for (let j = 0; j < positionsMap[i].length; j++) {
        this.heightMap[i].push(positionsMap[i][j][1])
      }
    }


  }

  lerp(a, b, x) {
    return a + (b - a) * x
  }

  hypotenuse(a, b) {
    return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2))
  }

  collision(lastPosition, position, movement, dimensions) {

    let xIndex = parseInt((position.x - this.xMin) / this.xWidth, 10)
    let zIndex = parseInt((position.z - this.zMin) / this.xWidth, 10)

    //console.log(xIndex + ", " + zIndex)

    let xPositionInSquare = ((position.x - this.xMin) % this.xWidth) / this.xWidth
    let zPositionInSquare = ((position.z - this.zMin) % this.xWidth) / this.xWidth

    //let yPositionX = this.lerp(this.heightMap[xIndex][zIndex], this.heightMap[xIndex+1][zIndex], xPositionInSquare)

    //console.log(xIndex / this.heightMap.length)

    let yPosition = -1000000

    if (0 <= xIndex && xIndex + 1 < this.heightMap.length && 0 <= zIndex && zIndex + 1 < this.heightMap[0].length) {
      let yMinX = this.lerp(this.heightMap[xIndex][zIndex], this.heightMap[xIndex][zIndex + 1], zPositionInSquare)
      let yPluX = this.lerp(this.heightMap[xIndex + 1][zIndex], this.heightMap[xIndex + 1][zIndex + 1], zPositionInSquare)

      yPosition = this.lerp(yMinX, yPluX, xPositionInSquare)
    }



    return {
      mx: {
        intersects: false,
        y: 0,
        z: 0,
        x: 0
      },
      my: {
        intersects: false,
        z: 0,
        x: 0,
        y: 0
      },
      mz: {
        intersects: false,
        x: 0,
        y: 0,
        z: 0
      },
      px: {
        intersects: false,
        y: 0,
        z: 0,
        x: 0
      },
      py: {
        intersects: (position.y < yPosition - dimensions.my),
        z: position.z,
        x: position.x,
        y: yPosition - dimensions.my
      },
      pz: {
        intersects: false,
        x: 0,
        y: 0,
        z: 0
      }
    }
  }

  remove() {
    this.model.delete()
  }


}






export default { webgl, Point, Model, ParticleEmitter, PhysicalObject, Particle, Player, Weapon, Platform, Ground }
